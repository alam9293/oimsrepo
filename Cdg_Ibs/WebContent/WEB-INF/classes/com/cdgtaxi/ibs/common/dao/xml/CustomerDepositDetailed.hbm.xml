<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN" 
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
    
<hibernate-mapping>
<!-- 
    Created by the Middlegen Hibernate plugin 2.1

    http://boss.bekk.no/boss/middlegen/
    http://www.hibernate.org/
-->

<sql-query name="customerDepositDetailedReceipts">
	<return-scalar column="cust_no" 			type="string"/>
	<return-scalar column="account_name" 		type="string"/>
	<return-scalar column="invoice_no"			type="string"/>
	<return-scalar column="invoice_date"		type="string"/>
	<return-scalar column="receipts_no"			type="string"/>
	<return-scalar column="receipts_date"		type="string"/>
	<return-scalar column="receipts_amt"		type="string"/>
	<return-scalar column="deposit_amt"			type="string"/>
	<return-scalar column="received_amt"		type="string"/>
	<return-scalar column="outstanding_amt"		type="string"/>
	<return-scalar column="status"				type="string"/>
	<![CDATA[
select main.CUST_NO, ACCOUNT_NAME, to_char(INVOICE_NO) as INVOICE_NO, to_char(INVOICE_DATE, 'dd/mm/yyyy') as INVOICE_DATE, replace(listagg(to_char(receipt.PAYMENT_RECEIPT_NO),',') within group (order by receipt.Payment_receipt_no), ',',',
') as receipts_no, replace(listagg(to_char(receipt.RECEIPT_DT,'dd/mm/yyyy'),',') within group (order by receipt.receipt_dt),',',',
') as receipts_date, replace(replace(listagg(trim(to_char(detail.APPLIED_AMOUNT, '999,999,990.00')||'^'),',') within group (order by detail.applied_amount), '^,', ',
'), '^', '') as receipts_amt, trim(to_char(deposit_amt, '999,999,990.00')) as deposit_amt, trim(to_char(received_amt, '999,999,990.00')) as received_amt, trim(to_char(outstanding_amt, '999,999,990.00')) as outstanding_amt, case when refund>0 then 'REFUND' when offset>0 then 'OFFSET' when outstanding_amt>0 then 'OUTSTANDING' else 'RECEIVED' end as status from (select acct.CUST_NO, acct.ACCOUNT_NAME, header.INVOICE_NO, header.INVOICE_HEADER_NO, header.INVOICE_DATE, header.NEW_TXN as deposit_amt, header.NEW_TXN - header.OUTSTANDING_AMOUNT as received_amt, header.OUTSTANDING_AMOUNT as outstanding_amt from BMTB_INVOICE_HEADER header
    inner join BMTB_INVOICE_DEPOSIT_TXN deposit_txn on header.INVOICE_HEADER_NO = deposit_txn.INVOICE_HEADER_NO
    inner join BMTB_INVOICE_SUMMARY summary on header.INVOICE_HEADER_NO = summary.INVOICE_HEADER_NO and summary.SUMMARY_TYPE = 'DP'
    left join AMTB_ACCOUNT acct on header.ACCOUNT_NO = acct.ACCOUNT_NO
    inner join FMTB_AR_CONT_CODE_MASTER ar on acct.AR_CONTROL_CODE_NO = ar.AR_CONTROL_CODE_NO
    inner join FMTB_ENTITY_MASTER entity on ar.ENTITY_NO = entity.ENTITY_NO
    inner join (select distinct(header.INVOICE_HEADER_NO) from BMTB_INVOICE_HEADER header
    left join BMTB_PAYMENT_RECEIPT_DETAIL detail on header.INVOICE_HEADER_NO = detail.INVOICE_HEADER_NO
    left join BMTB_PAYMENT_RECEIPT receipt on detail.PAYMENT_RECEIPT_NO = receipt.PAYMENT_RECEIPT_NO
    where ((:depositStart is null and :depositEnd is null)or(header.INVOICE_DATE between case when :depositStart is null then to_date(:depositEnd, 'yyyy-mm-dd hh24:mi:ss') else to_date(:depositStart, 'yyyy-mm-dd hh24:mi:ss') end and case when :depositEnd is null then to_date(:depositStart, 'yyyy-mm-dd hh24:mi:ss') else to_date(:depositEnd, 'yyyy-mm-dd hh24:mi:ss') end))
    and ((:receiptStart is null and :receiptEnd is null)or(receipt.RECEIPT_DT between case when :receiptStart is null then to_date(:receiptEnd, 'yyyy-mm-dd hh24:mi:ss') else to_date(:receiptStart, 'yyyy-mm-dd hh24:mi:ss') end and case when :receiptEnd is null then to_date(:receiptStart, 'yyyy-mm-dd hh24:mi:ss') else to_date(:receiptEnd, 'yyyy-mm-dd hh24:mi:ss') end))) receipts on receipts.INVOICE_HEADER_NO = header.INVOICE_HEADER_NO
    where acct.CUST_NO like :acctNo and acct.ACCOUNT_NAME like :acctName and (:entity is null or entity.ENTITY_NO = :entity)
) main left join BMTB_PAYMENT_RECEIPT_DETAIL detail on detail.INVOICE_HEADER_NO = main.INVOICE_HEADER_NO
    left join BMTB_PAYMENT_RECEIPT receipt on detail.PAYMENT_RECEIPT_NO = receipt.PAYMENT_RECEIPT_NO
    left join (select case when acct.CUST_NO is not null then acct.CUST_NO when parent.CUST_NO is not null then parent.CUST_NO else grand.CUST_NO end as cust_no, count(INVOICE_DEPOSIT_TXN_NO) as offset from BMTB_INVOICE_DEPOSIT_TXN deposit
    left join AMTB_ACCOUNT acct on deposit.ACCOUNT_NO = acct.ACCOUNT_NO
    left join AMTB_ACCOUNT parent on acct.PARENT_NO = parent.ACCOUNT_NO
    left join AMTB_ACCOUNT grand on parent.PARENT_NO = grand.ACCOUNT_NO
    where deposit.NOTE_NO is not null
    group by case when acct.CUST_NO is not null then acct.CUST_NO when parent.CUST_NO is not null then parent.CUST_NO else grand.CUST_NO end) offset on offset.CUST_NO = main.CUST_NO
    left join (select case when acct.CUST_NO is not null then acct.CUST_NO when parent.CUST_NO is not null then parent.CUST_NO else grand.CUST_NO end as cust_no, count(INVOICE_DEPOSIT_TXN_NO) as refund from BMTB_INVOICE_DEPOSIT_TXN deposit
    left join AMTB_ACCOUNT acct on deposit.ACCOUNT_NO = acct.ACCOUNT_NO
    left join AMTB_ACCOUNT parent on acct.PARENT_NO = parent.ACCOUNT_NO
    left join AMTB_ACCOUNT grand on parent.PARENT_NO = grand.ACCOUNT_NO
    where deposit.PAYMENT_RECEIPT_NO is not null
    group by case when acct.CUST_NO is not null then acct.CUST_NO when parent.CUST_NO is not null then parent.CUST_NO else grand.CUST_NO end) refund on refund.CUST_NO = main.CUST_NO
    where :depositStatus is null or (case when :depositStatus = 'OS' then OUTSTANDING_AMT when :depositStatus = 'RF' then refund when :depositStatus = 'OFF' then offset else -1 end > 0) or (case when :depositStatus = 'RC' then OUTSTANDING_AMT else -1 end = 0)
    group by main.CUST_NO, main.ACCOUNT_NAME, main.INVOICE_NO, main.INVOICE_HEADER_NO, main.INVOICE_DATE, main.deposit_amt, main.received_amt, main.outstanding_amt, offset.offset, refund.refund
    order by case when :sort = 'STATUS' then STATUS else null end, case when :sort = 'INVOICE_DATE' then main.INVOICE_DATE else null end, ACCOUNT_NAME
	]]>
</sql-query>
<sql-query name="customerDepositDetailedRefunds">
	<return-scalar column="cust_no" 		type="string"/>
	<return-scalar column="account_name" 	type="string"/>
	<return-scalar column="nos"				type="string"/>
	<return-scalar column="dates"			type="string"/>
	<return-scalar column="offset"			type="string"/>
	<return-scalar column="refund"			type="string"/>
	<return-scalar column="total_deposit"	type="string"/>
	<return-scalar column="balance"			type="string"/>
	<![CDATA[
  select acct.CUST_NO, acct.ACCOUNT_NAME, main.nos, main.dates, trim(to_char(main.offset, '999,999,990.00')) as offset, trim(to_char(main.refund, '999,999,990.00')) as refund, trim(to_char(deposit.total_deposit, '999,999,990.00')) as total_deposit, trim(to_char(deposit.total_deposit - case when main.offset is null then 0 else main.offset end - case when main.refund is null then 0 else main.refund end, '999,999,990.00')) as balance from
(select case when acct.CUST_NO is not null then acct.ACCOUNT_NO when parent.CUST_NO is not null then parent.ACCOUNT_NO else grand.ACCOUNT_NO end as account_no, 
listagg(case when note.NOTE_NO is null then receipt.PAYMENT_RECEIPT_NO else note.NOTE_NO end,',') within group (order by note.note_no, receipt.payment_receipt_no) as nos, 
 listagg(case when note.NOTE_NO is null then receipt.PAYMENT_DATE else to_date(to_char(note.CREATED_DT, 'yyyy-mm-dd'), 'yyyy-mm-dd') end,',') within group (order by note.note_no, receipt.payment_date, note.created_dt) as dates,
   listagg(note.NOTE_AMOUNT,',') within group (order by note.note_amount) as offset_string,
 sum(note.NOTE_AMOUNT) as offset, sum(receipt.PAYMENT_AMOUNT) as refund from BMTB_INVOICE_DEPOSIT_TXN deposit
    left join BMTB_NOTE note on deposit.NOTE_NO = note.NOTE_NO
    left join BMTB_PAYMENT_RECEIPT receipt on deposit.PAYMENT_RECEIPT_NO = receipt.PAYMENT_RECEIPT_NO
    inner join AMTB_ACCOUNT acct on deposit.ACCOUNT_NO = acct.ACCOUNT_NO
    left join AMTB_ACCOUNT parent on acct.PARENT_NO = parent.ACCOUNT_NO
    left join AMTB_ACCOUNT grand on parent.PARENT_NO = grand.ACCOUNT_NO
    inner join (select acct.ACCOUNT_NO from AMTB_ACCOUNT acct
        inner join BMTB_INVOICE_DEPOSIT_TXN deposit on acct.ACCOUNT_NO = deposit.ACCOUNT_NO
        inner join BMTB_INVOICE_HEADER header on deposit.INVOICE_HEADER_NO = header.INVOICE_HEADER_NO
        inner join BMTB_PAYMENT_RECEIPT_DETAIL detail on header.INVOICE_HEADER_NO = detail.INVOICE_HEADER_NO
        inner join BMTB_PAYMENT_RECEIPT receipt on detail.PAYMENT_RECEIPT_NO = receipt.PAYMENT_RECEIPT_NO
        where ((:depositStart is null and :depositEnd is null)or(header.INVOICE_DATE between case when :depositStart is null then to_date(:depositEnd, 'yyyy-mm-dd hh24:mi:ss') else to_date(:depositStart, 'yyyy-mm-dd hh24:mi:ss') end and case when :depositEnd is null then to_date(:depositStart, 'yyyy-mm-dd hh24:mi:ss') else to_date(:depositEnd, 'yyyy-mm-dd hh24:mi:ss') end))
        and ((:receiptStart is null and :receiptEnd is null)or(receipt.RECEIPT_DT between case when :receiptStart is null then to_date(:receiptEnd, 'yyyy-mm-dd hh24:mi:ss') else to_date(:receiptStart, 'yyyy-mm-dd hh24:mi:ss') end and case when :receiptEnd is null then to_date(:receiptStart, 'yyyy-mm-dd hh24:mi:ss') else to_date(:receiptEnd, 'yyyy-mm-dd hh24:mi:ss') end))) sub on sub.ACCOUNT_NO = case when acct.CUST_NO is not null then acct.ACCOUNT_NO when parent.CUST_NO is not null then parent.ACCOUNT_NO else grand.ACCOUNT_NO end
    where note.NOTE_NO is not null or receipt.PAYMENT_RECEIPT_NO is not null
    group by case when acct.CUST_NO is not null then acct.ACCOUNT_NO when parent.CUST_NO is not null then parent.ACCOUNT_NO else grand.ACCOUNT_NO end) main
    inner join AMTB_ACCOUNT acct on acct.ACCOUNT_NO = main.ACCOUNT_NO
    left join (select ACCOUNT_NO, sum(AMOUNT) as total_deposit from BMTB_INVOICE_DEPOSIT_TXN where NOTE_NO is null and PAYMENT_RECEIPT_NO is null group by ACCOUNT_NO) deposit on acct.ACCOUNT_NO = deposit.ACCOUNT_NO
    inner join FMTB_AR_CONT_CODE_MASTER ar on acct.AR_CONTROL_CODE_NO = ar.AR_CONTROL_CODE_NO
    inner join FMTB_ENTITY_MASTER entity on ar.ENTITY_NO = entity.ENTITY_NO
    where acct.CUST_NO like :acctNo and acct.ACCOUNT_NAME like :acctName and (:entity is null or entity.ENTITY_NO = :entity)
    order by acct.ACCOUNT_NAME
	]]>
</sql-query>
</hibernate-mapping>