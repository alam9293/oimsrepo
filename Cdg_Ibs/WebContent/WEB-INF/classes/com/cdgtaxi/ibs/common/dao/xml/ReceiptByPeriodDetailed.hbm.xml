<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN" 
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
    
<hibernate-mapping>
<!-- 
    Created by the Middlegen Hibernate plugin 2.1

    http://boss.bekk.no/boss/middlegen/
    http://www.hibernate.org/
-->

<sql-query name="receiptByPeriodDetailed">
	<return-scalar column="cust_no" 				type="string"/>
	<return-scalar column="account_name" 			type="string"/>
	<return-scalar column="payment_receipt_no"		type="string"/>
	<return-scalar column="receipt_dt"				type="string"/>
	<return-scalar column="cancel_dt" 				type="string"/>
	<return-scalar column="applied_amount" 			type="string"/>
	<return-scalar column="excess_amount" 			type="string"/>
	<return-scalar column="payment_amount" 			type="string"/>
	<return-scalar column="cancel_amount" 			type="string"/>
	<return-scalar column="net_amount" 				type="string"/>
	<return-scalar column="master_value" 			type="string"/>
	<return-scalar column="cheque_txn_ref_no"		type="string"/>
	<return-scalar column="bank_name"				type="string"/>
	<return-scalar column="name"					type="string"/>
	<![CDATA[
select 
top.cust_no as cust_no, 
top.account_name as account_name,
receipt.payment_receipt_no,
to_char(receipt.receipt_dt, 'dd/mm/yyyy') as receipt_dt, 
to_char(receipt.cancel_dt, 'dd/mm/yyyy') as cancel_dt, 
trim(to_char(receipt.payment_amount-excess_amount, '999,999,990.00')) as applied_amount, 
trim(to_char(receipt.excess_amount, '999,999,990.00')) as excess_amount, trim(to_char(receipt.payment_amount, '999,999,990.00')) as payment_amount, 
master_value, 
bank.BANK_NAME, 
case when cancel_dt is null then '0'
else trim(to_char(payment_amount, '999,999,990.00'))
end as cancel_amount,
case when cancel_dt is null then trim(to_char(payment_amount, '999,999,990.00'))
else '0'
end as net_amount,
case when cheque_no is null then to_char(payment_no)
else to_char(cheque_no)
end as cheque_txn_ref_no, sales.name from 
    BMTB_PAYMENT_RECEIPT receipt
    inner join AMTB_ACCOUNT acct on receipt.account_no = acct.account_no
    left join AMTB_ACCOUNT parent on acct.parent_no = parent.account_no
    left join AMTB_ACCOUNT grand on parent.parent_no = grand.account_no
    inner join AMTB_ACCOUNT top on (case when grand.cust_no is not null then grand.account_no when parent.cust_no is not null then parent.account_no else acct.account_no end) = top.account_no
	inner join FMTB_AR_CONT_CODE_MASTER ar on top.ar_control_code_no = ar.ar_control_code_no
	inner join FMTB_ENTITY_MASTER entity on ar.entity_no =entity.entity_no
    inner join (select distinct(payment_receipt_no) from BMTB_PAYMENT_RECEIPT_DETAIL detail, BMTB_INVOICE_HEADER header where detail.invoice_header_no = header.invoice_header_no and (:invoiceNo is null or header.INVOICE_NO = :invoiceNo)) detail on receipt.payment_receipt_no = detail.payment_receipt_no
    inner join MSTB_MASTER_TABLE master on receipt.PAYMENT_MODE = master.MASTER_NO
    left join MSTB_BANK_MASTER bank on bank.BANK_MASTER_NO = receipt.BANK
    left join (
        select max(effective_dt_from) as effective_dt_from, acct.ACCOUNT_NO, receipt.PAYMENT_RECEIPT_NO from BMTB_PAYMENT_RECEIPT receipt
        inner join AMTB_ACCOUNT acct on acct.ACCOUNT_NO = receipt.ACCOUNT_NO
        left join AMTB_ACCOUNT parent on parent.ACCOUNT_NO = acct.PARENT_NO
        left join AMTB_ACCOUNT grand on grand.ACCOUNT_NO = parent.PARENT_NO
        inner join AMTB_ACCOUNT top on (case when grand.cust_no is not null then grand.account_no when parent.cust_no is not null then parent.account_no else acct.account_no end) = top.account_no
        inner join AMTB_ACCT_SALESPERSON acct_sales on acct_sales.ACCOUNT_NO = top.account_no
        where acct_sales.effective_dt_from < receipt_dt and (acct_sales.effective_dt_from < acct_sales.effective_dt_to or acct_sales.effective_dt_to is null) group by acct.account_no, receipt.payment_receipt_no
    ) max_sales on receipt.payment_receipt_no = max_sales.payment_receipt_no and max_sales.account_no = acct.ACCOUNT_NO
    left join AMTB_ACCT_SALESPERSON acct_sales on max_sales.effective_dt_from = acct_sales.effective_dt_from and (acct_sales.effective_dt_from < acct_sales.effective_dt_to or acct_sales.effective_dt_to is null) and acct_sales.account_no = top.account_no
    left join MSTB_SALESPERSON sales on acct_sales.salesperson_no = sales.salesperson_no
    where ((:receiptStart is null and :receiptEnd is null)or(receipt.RECEIPT_DT between case when :receiptStart is null then to_date(:receiptEnd, 'yyyy-mm-dd hh24:mi:ss') else to_date(:receiptStart, 'yyyy-mm-dd hh24:mi:ss') end and case when :receiptEnd is null then to_date(:receiptStart, 'yyyy-mm-dd hh24:mi:ss') else to_date(:receiptEnd, 'yyyy-mm-dd hh24:mi:ss') end)) and
    ((:cancelStart is null and :cancelEnd is null)or(receipt.CANCEL_DT between case when :cancelStart is null then to_date(:cancelEnd, 'yyyy-mm-dd hh24:mi:ss') else to_date(:cancelStart, 'yyyy-mm-dd hh24:mi:ss') end and case when :cancelEnd is null then to_date(:cancelStart, 'yyyy-mm-dd hh24:mi:ss') else to_date(:cancelEnd, 'yyyy-mm-dd hh24:mi:ss') end)) and
    (:acctNo is null or top.cust_no like :acctNo) and
    (:acctName is null or top.ACCOUNT_NAME like :acctName) and
    (:receiptNo is null or receipt.PAYMENT_RECEIPT_NO = :receiptNo) and
    (:paymentMode is null or (master.MASTER_CODE = :paymentMode and master.MASTER_TYPE = 'PM')) and 
    (:entityNo is null or entity.ENTITY_NO = :entityNo)and
    (:salespersonNo is null or acct_sales.SALESPERSON_NO = :salespersonNo)
    order by case when :order = 'RD' then receipt.RECEIPT_DT else null end, case when :order = 'CN' then top.ACCOUNT_NAME when :order = 'PM' then master.MASTER_VALUE else null end, case when :order = 'RD' then receipt.PAYMENT_RECEIPT_NO else null end
	]]>
</sql-query>
</hibernate-mapping>