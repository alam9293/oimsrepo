<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN" 
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
    
<hibernate-mapping>
<!-- 
    Created by the Middlegen Hibernate plugin 2.1

    http://boss.bekk.no/boss/middlegen/
    http://www.hibernate.org/
-->

<sql-query name="refundDepositReport">
	<return-scalar column="cust_no" 			type="string"/>
	<return-scalar column="account_name" 		type="string"/>
	<return-scalar column="applied_amount"		type="string"/>
	<return-scalar column="invoice_no"			type="string"/>
	<return-scalar column="invoice_date"		type="string"/>
	<return-scalar column="payment_receipt_no"	type="string"/>
	<return-scalar column="receipt_dt"			type="string"/>
	<return-scalar column="terminate_dt"		type="string"/>
	<return-scalar column="close_dt"			type="string"/>
	<return-scalar column="acct_status"			type="string"/>
	<return-scalar column="refunded"			type="string"/>
	<return-scalar column="offset_outstanding"	type="string"/>
	<![CDATA[
select acct.CUST_NO,
	acct.ACCOUNT_NAME,
	trim(to_char(receipt_detail.APPLIED_AMOUNT, '999,999,990.00')) as APPLIED_AMOUNT,
	trim(to_char(header.INVOICE_NO, '999999990')) as INVOICE_NO,
	to_char(header.INVOICE_DATE, 'dd/mm/yyyy') as INVOICE_DATE,
	trim(to_char(receipt_detail.PAYMENT_RECEIPT_NO, '999999990')) as PAYMENT_RECEIPT_NO,
	to_char(receipt.RECEIPT_DT, 'dd/mm/yyyy') as RECEIPT_DT,
	to_char(terminate.EFFECTIVE_DT, 'dd/mm/yyyy') as terminate_dt,
	to_char(close.EFFECTIVE_DT, 'dd/mm/yyyy') as close_dt,
	status.ACCT_STATUS,
    case when payment_type.MASTER_CODE = 'MEMO' then 'YES' else 'NO' end as refunded,
    case when offset.OFFSET_OUTSTANDING > 0 then 'YES' else 'NO' end as offset_outstanding
    from BMTB_INVOICE_HEADER header
    inner join BMTB_INVOICE_DEPOSIT_TXN deposit on header.INVOICE_HEADER_NO = deposit.INVOICE_HEADER_NO
    inner join BMTB_PAYMENT_RECEIPT_DETAIL receipt_detail on receipt_detail.INVOICE_HEADER_NO = header.INVOICE_HEADER_NO
    inner join BMTB_PAYMENT_RECEIPT receipt on receipt.PAYMENT_RECEIPT_NO = receipt_detail.PAYMENT_RECEIPT_NO
    left join BMTB_INVOICE_DEPOSIT_TXN refund on refund.TXN_TYPE = 'F' and refund.ACCOUNT_NO = deposit.ACCOUNT_NO and refund.PAYMENT_RECEIPT_NO is not null
    left join BMTB_PAYMENT_RECEIPT refund_receipt on refund_receipt.PAYMENT_RECEIPT_NO = refund.PAYMENT_RECEIPT_NO
    left join MSTB_MASTER_TABLE payment_type on refund_receipt.PAYMENT_MODE = payment_type.MASTER_NO
    inner join AMTB_ACCOUNT acct on acct.ACCOUNT_NO = header.ACCOUNT_NO
    inner join FMTB_AR_CONT_CODE_MASTER ar on ar.ar_control_code_no = acct.ar_control_code_no
	inner join FMTB_ENTITY_MASTER entity on ar.entity_no =entity.entity_no
    left join AMTB_ACCT_STATUS terminate on terminate.ACCOUNT_NO = acct.ACCOUNT_NO and terminate.ACCT_STATUS = 'T'
    inner join AMTB_ACCT_STATUS close on close.ACCOUNT_NO = acct.ACCOUNT_NO and close.ACCT_STATUS = 'C'
    inner join (
select ACCOUNT_NO, max(EFFECTIVE_DT) as last_status_dt from AMTB_ACCT_STATUS where EFFECTIVE_DT < current_timestamp group by ACCOUNT_NO
    ) last_status on last_status.ACCOUNT_NO = acct.ACCOUNT_NO
    inner join AMTB_ACCT_STATUS status on status.ACCOUNT_NO = acct.ACCOUNT_NO and status.EFFECTIVE_DT = last_status.LAST_STATUS_DT
    left join (
select ISSUED_INVOICE_HEADER_NO, sum(NOTE_AMOUNT) as offset_outstanding from BMTB_NOTE group by ISSUED_INVOICE_HEADER_NO
    ) offset on offset.ISSUED_INVOICE_HEADER_NO = header.INVOICE_HEADER_NO
    where acct.CUST_NO like :acctNo and acct.ACCOUNT_NAME like :acctName
    and (
        ((:terminateStart is null and :terminateEnd is null)or(terminate.effective_dt between case when :terminateStart is null then to_date(:terminateEnd, 'yyyy-mm-dd hh24:mi:ss') else to_date(:terminateStart, 'yyyy-mm-dd hh24:mi:ss') end and case when :terminateEnd is null then to_date(:terminateStart, 'yyyy-mm-dd hh24:mi:ss') else to_date(:terminateEnd, 'yyyy-mm-dd hh24:mi:ss') end)) or
        ((:terminateStart is null and :terminateEnd is null)or(close.effective_dt between case when :terminateStart is null then to_date(:terminateEnd, 'yyyy-mm-dd hh24:mi:ss') else to_date(:terminateStart, 'yyyy-mm-dd hh24:mi:ss') end and case when :terminateEnd is null then to_date(:terminateStart, 'yyyy-mm-dd hh24:mi:ss') else to_date(:terminateEnd, 'yyyy-mm-dd hh24:mi:ss') end))
    )
    and (:acctStatus is null or status.ACCT_STATUS = :acctStatus)
    and (:refund is null or case when payment_type.MASTER_CODE = 'MEMO' then 'Y' else 'N' end = :refund)
    and (:entityNo is null or entity.entity_no = :entityNo)
    order by acct.ACCOUNT_NAME, acct.CUST_NO, header.INVOICE_NO, receipt.PAYMENT_RECEIPT_NO
	]]>
</sql-query>
</hibernate-mapping>