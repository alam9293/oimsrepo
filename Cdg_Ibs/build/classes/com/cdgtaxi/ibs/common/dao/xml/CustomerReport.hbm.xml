<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN" 
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
    
<hibernate-mapping>
<!-- 
    Created by the Middlegen Hibernate plugin 2.1

    http://boss.bekk.no/boss/middlegen/
    http://www.hibernate.org/
-->

<sql-query name="customerReport">
	<return-scalar column="cust_no" 					type="string"/>
	<return-scalar column="account_name" 				type="string"/>
	<return-scalar column="subscribed_product_type"		type="string"/>
	<return-scalar column="ace_indicator"			    type="string"/>
	<return-scalar column="master_value"				type="string"/>
	<return-scalar column="created_dt" 					type="string"/>
	<return-scalar column="effective_dt" 				type="string"/>
	<return-scalar column="acct_status" 				type="string"/>
	<return-scalar column="trip_start_dt" 				type="string"/>
	<return-scalar column="product_type_id"				type="string"/>
	<return-scalar column="credit_limit" 				type="string"/>
	<return-scalar column="credit_balance" 				type="string"/>
	<return-scalar column="main_contact_name"			type="string"/>
	<return-scalar column="main_contact_no" 			type="string"/>
	<return-scalar column="main_contact_fax" 			type="string"/>
	<return-scalar column="main_contact_email"			type="string"/>
	<return-scalar column="main_address_area"			type="string"/>
	<return-scalar column="main_address_block"			type="string"/>
	<return-scalar column="main_address_street"			type="string"/>
	<return-scalar column="main_address_unit"			type="string"/>
	<return-scalar column="main_address_building"		type="string"/>
	<return-scalar column="main_address_country"		type="string"/>
	<return-scalar column="main_address_state"			type="string"/>
	<return-scalar column="main_address_city"			type="string"/>
	<return-scalar column="main_address_postal"			type="string"/>
	<return-scalar column="billing_cycle"				type="string"/>
	<return-scalar column="total_invoice_amount"		type="string"/>
	<return-scalar column="name"						type="string"/>
	<return-scalar column="product_types"				type="string"/>
	<return-scalar column="credit_term_plan_name"		type="string"/>
	<return-scalar column="early_payment_plan_name"		type="string"/>
	<return-scalar column="late_payment_plan_name"		type="string"/>
	<return-scalar column="volume_discount_plan_name"	type="string"/>
	<return-scalar column="promo_name"					type="string"/>
	<return-scalar column="e_invoice_flag"				type="string"/>
	<return-scalar column="payment_mode"				type="string"/>
	<return-scalar column="bank"						type="string"/>
	<return-scalar column="branch"						type="string"/>
	<return-scalar column="bank_acct_no"				type="string"/>
	<return-scalar column="ad_fee"						type="string"/>
  	<return-scalar column="GOVT_EINV_FLAGGED"           type="string"/>
	<return-scalar column="PUBBS_FLAG"				    type="string"/>
	<return-scalar column="OUTSOURCE_PRINTING_FLAG"	    type="string"/>
	<return-scalar column="FI_FLAG"					    type="string"/>
	<![CDATA[
	select
		temp.*,
		last_invoice.total_invoice_amount, 
		subscriptions.product_types, credit_term.CREDIT_TERM_PLAN_NAME,
		early_pymt.EARLY_PAYMENT_PLAN_NAME, late_pymt.LATE_PAYMENT_PLAN_NAME, vol_dis.VOLUME_DISCOUNT_PLAN_NAME, promo.PROMO_NAME,
		to_char(last_txn.trip_start_dt, 'dd/mm/yyyy') as trip_start_dt, last_txn.product_type_id,
		temp_extra.ad_fee,temp_extra.bank_acct_no,temp_extra.bank,temp_extra.branch,temp_extra.payment_mode,
    case when govt_einv.VALUE is null then 'NO' else 'YES' end as GOVT_EINV_FLAGGED
	FROM(
		select
			distinct(acct.CUST_NO), 
			acct.account_no,
			acct.ACCOUNT_NAME, 
			subscribed.subscribed_product_type,
		   	acct.ace_indicator as ace_indicator,
			industry.master_value, 
			to_char(acct.CREATED_DT, 'dd/mm/yyyy') as created_dt, 
			to_char(case when t_status.effective_dt is not null then t_status.effective_dt else c_status.effective_dt end, 'dd/mm/yyyy') as effective_dt, 
			status.acct_status, 
			trim(to_char(acct.credit_limit, '999,999,990.00')) as credit_limit, 
			trim(to_char(acct.credit_balance, '999,999,990.00')) as credit_balance,
			case when contact.main_contact_sal is not null then main_sal.master_value || ' ' else '' end || contact.main_contact_name || case when contact.sub_contact_name is not null then ' / ' || case when contact.sub_contact_sal is not null then sub_sal.master_value || ' ' else '' end || contact.sub_contact_name else '' end as main_contact_name,
			contact.main_contact_tel || case when contact.main_contact_fax is not null then ', ' || contact.main_contact_fax else '' end as main_contact_no,
			contact.main_contact_fax, contact.main_contact_email,
		    	--address
		    (case when contact.address_area is NULL then '' else contact.address_area End ) as main_address_area
		        ,
		    (case when contact.address_block is NULL then '' else contact.address_block End ) as main_address_block
		        ,
		    (case when contact.address_street is NULL then '' else contact.address_street End ) as main_address_street
		        ,
		    (case when contact.address_unit is NULL then '' else  contact.address_unit End ) as main_address_unit
		        ,
		    (case when contact.address_building is NULL then '' else contact.address_building End ) as main_address_building
		        ,
		    (case when contact.address_country is NULL then '' else contact_country.master_value End ) as main_address_country
		        ,
		    (case when contact.address_state is NULL then '' else  contact.address_state End ) as main_address_state
		        ,
		    (case when contact.address_city is NULL then '' else  contact.address_city End ) as main_address_city
		        ,
		    (case when contact.address_postal is NULL then '' else contact.address_postal End ) as main_address_postal,
		    bill_cycle.BILLING_CYCLE,
		    sales.NAME, 
		    acct.E_INVOICE_FLAG,
 	   	    case when acct.pubbs_flag is null then 'NO' 
		    	 when acct.pubbs_flag = 'N' then 'NO' else 'YES' end as pubbs_flag,
		    case when acct.OUTSOURCE_PRINTING_FLAG is null then 'NO' 
		    	 when acct.OUTSOURCE_PRINTING_FLAG = 'N' then 'NO' else 'YES' end as OUTSOURCE_PRINTING_FLAG,
		 	case when acct.fi_flag is null then 'NO' 
		    	 when acct.fi_flag = 'N' then 'NO' else 'YES' end as fi_flag
		    from AMTB_ACCOUNT acct
		    inner join (
		    		select cast (listagg(PRODUCT_TYPE_ID, ',') within group(order by product_type_id) as varchar2(4000)) as subscribed_product_type, account_no
		    		from AMTB_SUBSC_TO where account_no in (
		    			select account_no from AMTB_SUBSC_TO 
		    			where (:productTypeId is null or PRODUCT_TYPE_ID = :productTypeId)
		    		) group by ACCOUNT_NO
		    	) subscribed on subscribed.ACCOUNT_NO = acct.ACCOUNT_NO 
		    		and acct.CUST_NO is not null 
		    		and acct.CUST_NO like :acctNo 
		    		and acct.ACCOUNT_NAME like :acctName 
		    		and (
		    			(:joinStart is null and :joinEnd is null)
		    			or(acct.CREATED_DT between 
		    				case when :joinStart is null then to_date(:joinEnd, 'yyyy-mm-dd hh24:mi:ss') 
		    				else to_date(:joinStart, 'yyyy-mm-dd hh24:mi:ss') end 
		    				and 
		    				case when :joinEnd is null then to_date(:joinStart, 'yyyy-mm-dd hh24:mi:ss') 
		    				else to_date(:joinEnd, 'yyyy-mm-dd hh24:mi:ss') end)
		    			)
		    inner join AMTB_ACCT_TYPE type on acct.ACCT_TYPE_NO = type.ACCT_TYPE_NO and type.ACCT_TYPE_NO in (select acct_type_no from AMTB_ACCT_TYPE where ACCT_TEMPLATE like :acctTypeNo)
		    left join AMTB_CORPORATE_DETAIL corp_details on corp_details.ACCOUNT_NO = acct.ACCOUNT_NO
		    left join AMTB_PERSONAL_DETAIL pers_details on pers_details.ACCOUNT_NO = acct.ACCOUNT_NO
		    inner join MSTB_MASTER_TABLE industry on case when corp_details.INDUSTRY is not null then corp_details.INDUSTRY else pers_details.INDUSTRY end = industry.MASTER_NO and (:industryNo is null or (industry.MASTER_CODE = :industryNo and industry.MASTER_TYPE = 'IND'))
		    left join AMTB_ACCT_STATUS t_status on t_status.ACCOUNT_NO = acct.ACCOUNT_NO and t_status.ACCT_STATUS = 'T'
		    left join AMTB_ACCT_STATUS c_status on c_status.ACCOUNT_NO = acct.ACCOUNT_NO and c_status.ACCT_STATUS = 'C'
		    inner join (select max(EFFECTIVE_DT) as effective_dt, account_no from AMTB_ACCT_STATUS where EFFECTIVE_DT < systimestamp group by account_no) last_eff_status on last_eff_status.account_no = acct.account_no
		    inner join AMTB_ACCT_STATUS status on last_eff_status.effective_dt = status.effective_dt and status.account_no = acct.account_no and (:acctStatus is null or status.ACCT_STATUS = :acctStatus)
		    left join AMTB_ACCT_MAIN_CONTACT main on main.ACCOUNT_NO = acct.ACCOUNT_NO and main.MAIN_CONTACT_TYPE = 'S'
		    left join AMTB_CONTACT_PERSON contact on main.CONTACT_PERSON_NO = contact.CONTACT_PERSON_NO
		    left join MSTB_MASTER_TABLE contact_country on contact.ADDRESS_COUNTRY = contact_country.MASTER_NO
		    left join MSTB_MASTER_TABLE main_sal on contact.main_contact_sal = main_sal.master_no
		    left join MSTB_MASTER_TABLE sub_sal on contact.sub_contact_sal = sub_sal.master_no
		    left join (select max(EFFECTIVE_DATE) as effective_date, account_no from AMTB_ACCT_BILL_CYCLE group by account_no) last_eff_bill_cycle on last_eff_bill_cycle.account_no = acct.account_no
		    left join AMTB_ACCT_BILL_CYCLE bill_cycle on last_eff_bill_cycle.effective_date = bill_cycle.effective_date and bill_cycle.account_no = acct.account_no
		    inner join (
				select ACCOUNT_NO, max(EFFECTIVE_DT_FROM) as last_effective_dt_from from AMTB_ACCT_SALESPERSON where effective_dt_from < systimestamp group by ACCOUNT_NO
		    ) last_acct_sales on acct.ACCOUNT_NO = last_acct_sales.ACCOUNT_NO
		    inner join AMTB_ACCT_SALESPERSON acct_sales on acct.account_no = acct_sales.account_no and last_acct_sales.LAST_EFFECTIVE_DT_FROM = acct_sales.EFFECTIVE_DT_FROM and ((acct_sales.EFFECTIVE_DT_FROM < systimestamp and acct_sales.EFFECTIVE_DT_TO IS null) OR systimestamp between acct_sales.EFFECTIVE_DT_FROM and acct_sales.EFFECTIVE_DT_TO)
		    inner join MSTB_SALESPERSON sales on acct_sales.SALESPERSON_NO = sales.SALESPERSON_NO
		    inner join FMTB_AR_CONT_CODE_MASTER ar on acct.AR_CONTROL_CODE_NO = ar.AR_CONTROL_CODE_NO
		    inner join FMTB_ENTITY_MASTER entity on ar.entity_no = entity.entity_no
		    --WHERE CLAUSE
		    where (
		        ((:terminateStart is null and :terminateEnd is null)or(t_status.effective_dt between case when :terminateStart is null then to_date(:terminateEnd, 'yyyy-mm-dd hh24:mi:ss') else to_date(:terminateStart, 'yyyy-mm-dd hh24:mi:ss') end and case when :terminateEnd is null then to_date(:terminateStart, 'yyyy-mm-dd hh24:mi:ss') else to_date(:terminateEnd, 'yyyy-mm-dd hh24:mi:ss') end)) or
		        ((:terminateStart is null and :terminateEnd is null)or(c_status.effective_dt between case when :terminateStart is null then to_date(:terminateEnd, 'yyyy-mm-dd hh24:mi:ss') else to_date(:terminateStart, 'yyyy-mm-dd hh24:mi:ss') end and case when :terminateEnd is null then to_date(:terminateStart, 'yyyy-mm-dd hh24:mi:ss') else to_date(:terminateEnd, 'yyyy-mm-dd hh24:mi:ss') end))
		    )
		    and (:entityNo is null or entity.entity_no =:entityNo)
		    and (:salespersonNo is null or sales.SALESPERSON_NO = :salespersonNo)
	) temp
		--Last Invoice
	    left join (
	        select top.ACCOUNT_NO, sum(header.NEW_TXN) as total_invoice_amount
	            from BMTB_INVOICE_HEADER header
	            left join AMTB_ACCOUNT acct on header.debt_to = acct.ACCOUNT_NO
	            left join AMTB_ACCOUNT parent on acct.PARENT_NO = parent.ACCOUNT_NO
	            left join AMTB_ACCOUNT grand on parent.PARENT_NO = grand.ACCOUNT_NO
	            inner join AMTB_ACCOUNT top on (case when grand.cust_no is not null then grand.account_no when parent.cust_no is not null then parent.account_no else acct.account_no end) = top.account_no
	            inner join AMTB_ACCT_TYPE type on top.ACCT_TYPE_NO = type.ACCT_TYPE_NO
	            where header.NEW_TXN != 0 AND header.INVOICE_FORMAT in ('A','S','P')
	            AND exists (
	                select 1
	                    from (
	                        select distinct top.ACCOUNT_NO, first_value(sq_header.INVOICE_DATE) over (Partition by top.ACCOUNT_NO order by sq_header.INVOICE_DATE desc) as INVOICE_DATE 
                                  from BMTB_INVOICE_HEADER sq_header
                                  left join AMTB_ACCOUNT acct on sq_header.debt_to = acct.ACCOUNT_NO 
                                  left join AMTB_ACCOUNT parent on acct.PARENT_NO = parent.ACCOUNT_NO 
                                  left join AMTB_ACCOUNT grand on parent.PARENT_NO = grand.ACCOUNT_NO 
                                  inner join AMTB_ACCOUNT top on (case when grand.cust_no is not null then grand.account_no when parent.cust_no is not null then parent.account_no else acct.account_no end) = top.account_no
	                    ) temp
	                    where temp.ACCOUNT_NO = top.ACCOUNT_NO and temp.INVOICE_DATE = header.INVOICE_DATE
	            )
	            AND exists (
	              		select acct_type_no
	              		from AMTB_ACCT_TYPE 
	              		where type.ACCT_TYPE_NO = ACCT_TYPE_NO AND ACCT_TEMPLATE like :acctTypeNo
	              )
	            group by top.ACCOUNT_NO
	    ) last_invoice on last_invoice.ACCOUNT_NO = temp.account_no
		--transactions
		left join(
			select 
				distinct top.account_no, 
				first_value(TRIP_START_DT) over (Partition by top.ACCOUNT_NO order by TRIP_START_DT desc) as TRIP_START_DT,
				first_value(PRODUCT_TYPE_ID) over (Partition by top.ACCOUNT_NO order by TRIP_START_DT desc) as PRODUCT_TYPE_ID
			from TMTB_ACQUIRE_TXN txn
			inner join AMTB_ACCOUNT acct on txn.ACCOUNT_NO = acct.ACCOUNT_NO
			left join AMTB_ACCOUNT parent on acct.PARENT_NO = parent.ACCOUNT_NO
			left join AMTB_ACCOUNT grand on parent.PARENT_NO = grand.ACCOUNT_NO
			inner join AMTB_ACCOUNT top on (case when grand.cust_no is not null then grand.account_no when parent.cust_no is not null then parent.account_no else acct.account_no end) = top.account_no
			inner join AMTB_ACCT_TYPE type on top.ACCT_TYPE_NO = type.ACCT_TYPE_NO
			where 
			txn.TRIP_START_DT between sysdate - (365) and sysdate
			AND
			exists (
				select acct_type_no
				from AMTB_ACCT_TYPE 
				where type.ACCT_TYPE_NO = ACCT_TYPE_NO AND ACCT_TEMPLATE like :acctTypeNo
			)
		) last_txn on last_txn.account_no = temp.account_no
	    --Subscription
	    left join (
			select 
			subscriptions.ACCOUNT_NO, replace(
				listagg(subscriptions.PRODUCT_TYPE_ID || ' - ' ||
	       		case when product_discount_detail.PRODUCT_DISCOUNT is not null then product_discount_detail.PRODUCT_DISCOUNT || '%' else '0%' end ||
	        		case when rewards.REWARD_PLAN_NAME is not null then '(' || rewards.REWARD_PLAN_NAME || ')' else '(NA)' end
	    			, ',') within group(order by subscriptions.product_type_id) , ',', ', '
	    		) as product_types 
	    		from AMTB_SUBSC_TO subscriptions
	    		left join MSTB_PROD_DISC_MASTER product_discount on subscriptions.PRODUCT_DISCOUNT_PLAN_NO = product_discount.PRODUCT_DISCOUNT_PLAN_NO
	    		left join (
				select PRODUCT_DISCOUNT_PLAN_NO, max(EFFECTIVE_DT) as max_effective_dt 
				from MSTB_PROD_DISC_DETAIL 
				where EFFECTIVE_DT < current_timestamp 
				group by PRODUCT_DISCOUNT_PLAN_NO
	    		) latest_product_discount_detail on product_discount.PRODUCT_DISCOUNT_PLAN_NO = latest_product_discount_detail.PRODUCT_DISCOUNT_PLAN_NO
	    		left join MSTB_PROD_DISC_DETAIL product_discount_detail on product_discount_detail.PRODUCT_DISCOUNT_PLAN_NO = product_discount.PRODUCT_DISCOUNT_PLAN_NO and product_discount_detail.EFFECTIVE_DT = latest_product_discount_detail.MAX_EFFECTIVE_DT
	    		left join LRTB_REWARD_MASTER rewards on subscriptions.REWARD_PLAN_NO = rewards.REWARD_PLAN_NO
	    		group by subscriptions.ACCOUNT_NO
	    ) subscriptions on subscriptions.ACCOUNT_NO = temp.ACCOUNT_NO
	    --CREDIT TERM
	    inner join (
			select credit_term.ACCOUNT_NO, term_master.CREDIT_TERM_PLAN_NAME
			from AMTB_ACCT_CRED_TERM credit_term
	    		inner join (
				select ACCOUNT_NO, max(EFFECTIVE_DATE) as max_effective_date 
				from AMTB_ACCT_CRED_TERM 
				where EFFECTIVE_DATE < current_timestamp 
				group by ACCOUNT_NO
	    		) last_credit_term on credit_term.ACCOUNT_NO = last_credit_term.ACCOUNT_NO and credit_term.EFFECTIVE_DATE = last_credit_term.MAX_EFFECTIVE_DATE
	    		inner join MSTB_CREDIT_TERM_MASTER term_master on credit_term.CREDIT_TERM_PLAN_NO = term_master.CREDIT_TERM_PLAN_NO
	    ) credit_term on credit_term.ACCOUNT_NO = temp.ACCOUNT_NO
	    --addon default payment mode, bank, branch, bank account no, base admin fee
	    inner join (
			select acct.ACCOUNT_NO
				 ,temp_amtb_admin.plan_no
				 ,mstb_admin_fee.admin_fee_plan_name as ad_fee
				 ,acct.BANK_ACCT_NO
				 ,mstb_bank.BANK_NAME as bank
				 ,mstb_bank_branch.BRANCH_NAME as branch
				 ,mstb_default_pymt.MASTER_VALUE as payment_mode
			from AMTB_ACCOUNT acct 
				left join MSTB_BANK_MASTER mstb_bank on mstb_bank.BANK_MASTER_NO=acct.BANK_MASTER_NO
				left join MSTB_BRANCH_MASTER mstb_bank_branch on mstb_bank_branch.BRANCH_MASTER_NO=acct.BRANCH_MASTER_NO
				left join MSTB_MASTER_TABLE mstb_default_pymt on mstb_default_pymt.MASTER_NO=acct.DEFAULT_PAYMENT_MODE
				inner join (
					SELECT DISTINCT account_no, 
						first_value(ADMIN_FEE_PLAN_NO) OVER (PARTITION BY account_no ORDER BY EFFECTIVE_DATE DESC) AS plan_no
					FROM AMTB_ACCT_ADMIN_FEE
				) temp_amtb_admin on temp_amtb_admin.ACCOUNT_NO=acct.ACCOUNT_NO
				inner join MSTB_ADMIN_FEE_MASTER mstb_admin_fee on mstb_admin_fee.admin_fee_plan_no=temp_amtb_admin.plan_no
	    ) temp_extra on temp_extra.ACCOUNT_NO = temp.ACCOUNT_NO
	    --EARLY PAYMENT
	    left join (
			select early_pymt.ACCOUNT_NO, early_pymt_master.EARLY_PAYMENT_PLAN_NAME 
			from AMTB_ACCT_EARLY_PYMT early_pymt
	    		inner join  (
				select ACCOUNT_NO, max(EFFECTIVE_DATE) as max_effective_date 
				from AMTB_ACCT_EARLY_PYMT 
				where EFFECTIVE_DATE < current_timestamp 
				group by ACCOUNT_NO
	    		) last_early_pymt on early_pymt.ACCOUNT_NO = last_early_pymt.ACCOUNT_NO and early_pymt.EFFECTIVE_DATE = last_early_pymt.MAX_EFFECTIVE_DATE
	    		inner join MSTB_EARLY_PAYMENT_MASTER early_pymt_master on early_pymt.EARLY_PAYMENT_PLAN_NO = early_pymt_master.EARLY_PAYMENT_PLAN_NO
	    ) early_pymt on early_pymt.ACCOUNT_NO = temp.ACCOUNT_NO
	    --LATE PAYMENT
	    inner join (
			select late_pymt.ACCOUNT_NO, late_pymt_master.LATE_PAYMENT_PLAN_NAME 
			from AMTB_ACCT_LATE_PYMT late_pymt
		    	inner join  (
				select ACCOUNT_NO, max(EFFECTIVE_DATE) as max_effective_date 
				from AMTB_ACCT_LATE_PYMT 
				where EFFECTIVE_DATE < current_timestamp 
				group by ACCOUNT_NO
		    	) last_late_pymt on late_pymt.ACCOUNT_NO = last_late_pymt.ACCOUNT_NO and late_pymt.EFFECTIVE_DATE = last_late_pymt.MAX_EFFECTIVE_DATE
	    		inner join MSTB_LATE_PAYMENT_MASTER late_pymt_master on late_pymt.LATE_PAYMENT_PLAN_NO = late_pymt_master.LATE_PAYMENT_PLAN_NO
	    ) late_pymt on late_pymt.ACCOUNT_NO = temp.ACCOUNT_NO
	    --VOLUME DISC
	    left join (
			select vol_dis.ACCOUNT_NO, vol_dis_master.VOLUME_DISCOUNT_PLAN_NAME 
			from AMTB_ACCT_VOL_DISC vol_dis
		    inner join (
				select ACCOUNT_NO, max(EFFECTIVE_DATE) as max_effective_date 
				from AMTB_ACCT_VOL_DISC where EFFECTIVE_DATE < current_timestamp group by ACCOUNT_NO
		    ) last_vol_dis on vol_dis.ACCOUNT_NO = last_vol_dis.ACCOUNT_NO and vol_dis.EFFECTIVE_DATE = last_vol_dis.MAX_EFFECTIVE_DATE
	    		inner join MSTB_VOL_DISC_MASTER vol_dis_master on vol_dis.VOLUME_DISCOUNT_PLAN_NO = vol_dis_master.VOLUME_DISCOUNT_PLAN_NO
	    ) vol_dis on vol_dis.ACCOUNT_NO = temp.ACCOUNT_NO
	    --PROMOTION
	    left join (
	    	select acct_promo.ACCOUNT_NO, replace(listagg(promo_detail.NAME, ',') within group(order by promo_detail.NAME), ',', ', ') as promo_name 
			from AMTB_ACCT_PROMOTION acct_promo
	    		inner join MSTB_PROMOTION promo on acct_promo.PROMO_NO = promo.PROMO_NO
	    		inner join MSTB_PROMO_DETAIL promo_detail on promo_detail.PROMO_NO = promo.PROMO_NO
	    		where acct_promo.EFFECTIVE_DATE_FROM < current_timestamp and (acct_promo.EFFECTIVE_DATE_TO is null or acct_promo.EFFECTIVE_DATE_TO > current_timestamp)
	    		group by acct_promo.ACCOUNT_NO
	    ) promo on promo.ACCOUNT_NO = temp.ACCOUNT_NO
      --GOVT EINV
      left join (
        select
        distinct topAcct.ACCOUNT_NO,
        1 as VALUE
        from AMTB_ACCOUNT acct
        left join AMTB_ACCOUNT acct2 on acct.PARENT_NO = acct2.ACCOUNT_NO
        left join AMTB_ACCOUNT acct3 on acct2.PARENT_NO = acct3.ACCOUNT_NO
        left join AMTB_ACCOUNT topAcct on topAcct.CUST_NO = case when acct3.CUST_NO is not null then acct3.CUST_NO when acct2.CUST_NO is not null then acct2.CUST_NO else acct.CUST_NO end
        where acct.GOVT_E_INVOICE_FLAG != 'N'
      ) govt_einv on govt_einv.ACCOUNT_NO = temp.ACCOUNT_NO
	order by 
		case when :sortBy = 'AN' then temp.ACCOUNT_NAME else temp.MASTER_VALUE end, 
		case when :sortBy = 'AN' then temp.CUST_NO else null end
	]]>
</sql-query>
</hibernate-mapping>