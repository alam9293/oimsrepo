<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN" 
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
    
<hibernate-mapping>
<!-- 
    Created by the Middlegen Hibernate plugin 2.1

    http://boss.bekk.no/boss/middlegen/
    http://www.hibernate.org/
-->

<sql-query name="prepaidUsage">
	<return-scalar column="account_no" 		type="string"/>
	<return-scalar column="account_name"	type="string"/>
	<return-scalar column="join_date"		type="string"/>
	<return-scalar column="account_status"	type="string"/>
	<return-scalar column="months_join"		type="string"/>
	<return-scalar column="purchase_amt"	type="string"/>
	<return-scalar column="top_up"			type="string"/>
	<return-scalar column="booking"			type="string"/>
	<return-scalar column="trips"			type="string"/>
	<return-scalar column="booking_percent"	type="string"/>
	<![CDATA[
WITH purchase_info
AS
(
  select top.account_no as top_account_no, sum(txn.APPLY_CARD_VALUE) as total_purchase, sum(case when txn.txn_type ='TOP_UP' then 1 else 0 end) as count_top_up
  from pmtb_prepaid_card_txn txn
  left join pmtb_product product on  txn.PMTB_PRODUCT = product.product_no
  left join AMTB_ACCOUNT acct on product.ACCOUNT_NO = acct.ACCOUNT_NO
  left join AMTB_ACCOUNT parent on acct.PARENT_NO = parent.ACCOUNT_NO
  left join AMTB_ACCOUNT grand on parent.PARENT_NO = grand.ACCOUNT_NO
  left join AMTB_ACCOUNT top on (case when grand.cust_no is not null then grand.account_no when parent.cust_no is not null then parent.account_no else acct.account_no end) = top.account_no
  left join pmtb_prepaid_req req on txn.PMTB_PREPAID_REQ = req.req_no
  left join bmtb_invoice_header header on header.invoice_header_no =  req.BMTB_INVOICE_HEADER
  where txn.txn_type in ('ISSUE', 'TOP_UP')
  and header.invoice_status = 'C'
  and (:productTypeId is null or product.product_type_id = :productTypeId)
  group by top.account_no
),
trips_info
AS
(
  select top.account_no as top_account_no, count(1) as total_trips,  count(case when substr(trip.job_no, 0 , 1) in (1,2,3) then 1 end) as total_booking
  from tmtb_acquire_txn trip
  left join pmtb_product product on  trip.product_no = product.product_no
  left join AMTB_ACCOUNT acct on product.ACCOUNT_NO = acct.ACCOUNT_NO
  left join AMTB_ACCOUNT parent on acct.PARENT_NO = parent.ACCOUNT_NO
  left join AMTB_ACCOUNT grand on parent.PARENT_NO = grand.ACCOUNT_NO
  left join AMTB_ACCOUNT top on (case when grand.cust_no is not null then grand.account_no when parent.cust_no is not null then parent.account_no else acct.account_no end) = top.account_no
  where (:productTypeId is null or product.product_type_id = :productTypeId)
  and
  (
    (:tripStartDate is null and :tripEndDate is null)
    or
    (
      trip.trip_start_dt between 
        case when :tripStartDate is null 
        then 
          to_date(:tripEndDate||' 00:00:00', 'yyyy-mm-dd hh24:mi:ss')
        else 
          to_date(:tripStartDate||' 00:00:00', 'yyyy-mm-dd hh24:mi:ss')
        end
       and 
        case when :tripEndDate is null 
        then 
          to_date(:tripStartDate||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss')
        else 
          to_date(:tripEndDate||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss')
        end
    )
  )
  and trip.txn_status not in ('V', 'R')
  group by top.account_no
),
usage_info 
AS
(
  select 
  top.cust_no as account_no, 
  top.account_name as account_name,
  top.created_dt as join_date,
  case when last_eff_status.acct_status='T'
    then decode(floor(MONTHS_BETWEEN(sysdate,last_eff_status.effective_dt)), 0, 1, floor(MONTHS_BETWEEN(sysdate,last_eff_status.effective_dt)))
    else decode(floor(MONTHS_BETWEEN(sysdate,top.created_dt)), 0, 1, floor(MONTHS_BETWEEN(sysdate,top.created_dt)))
  end
  as months_join,
  last_eff_status.acct_status as account_status,
  purchase_info.total_purchase as purchase_amt,
  purchase_info.count_top_up as top_up,
  NVL(trips_info.total_booking, 0) as booking,
  NVL(total_trips, 0) as trips,
  round(NVL(trips_info.total_booking / total_trips * 100, 0), 0) as booking_percent
  from amtb_account top
  left join (select max(acct_status_no) as acct_status_no, account_no from AMTB_ACCT_STATUS where EFFECTIVE_DT < systimestamp group by account_no) temp_status on top.account_no = temp_status.account_no
  inner join AMTB_ACCT_STATUS last_eff_status on last_eff_status.acct_status_no = temp_status.acct_status_no
  left join AMTB_ACCT_TYPE type on top.ACCT_TYPE_NO = type.ACCT_TYPE_NO
  left join FMTB_AR_CONT_CODE_MASTER ar on top.ar_control_code_no = ar.ar_control_code_no
  left join FMTB_ENTITY_MASTER entity on ar.entity_no =entity.entity_no  
  left join purchase_info purchase_info on top.account_no = purchase_info.top_account_no
  left join trips_info trips_info on top.account_no = trips_info.top_account_no
  where (purchase_info.top_account_no is not null or trips_info.top_account_no is not null)
    and (:acctType is null or type.ACCT_TEMPLATE =:acctType)
    and (:acctNo is null or top.cust_no =:acctNo)
    and (:acctName is null or top.account_name like '%' || :acctName || '%')
    and (:acctStatus is null or last_eff_status.acct_status = :acctStatus)
    and
    (
        (:joinStartDate is null and :joinEndDate is null)
        or
        (
          top.created_dt between 
            case when :joinStartDate is null 
            then 
              to_date(:joinEndDate||' 00:00:00', 'yyyy-mm-dd hh24:mi:ss')
            else 
              to_date(:joinStartDate||' 00:00:00', 'yyyy-mm-dd hh24:mi:ss')
            end
           and 
            case when :joinEndDate is null 
            then 
              to_date(:joinStartDate||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss')
            else 
              to_date(:joinEndDate||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss')
            end
        )
     )
     and (:entityNo is null or entity.ENTITY_NO = :entityNo)
) select
account_no,
account_name,
to_char(join_date, 'DD-MON-YYYY') as join_date,
months_join,
account_status,
purchase_amt,
top_up,
booking,
trips,
booking_percent
from usage_info
order by 
  case :sortBy 
    when 'NOM' then decode(floor(months_join), 0, 1, floor(months_join)) 
    when 'TU' then top_up
    when 'PA' then purchase_amt
  end
desc
   
  
	]]>
</sql-query>
</hibernate-mapping>