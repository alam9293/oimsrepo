<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN" 
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
    
<hibernate-mapping>
<!-- 
    Created by the Middlegen Hibernate plugin 2.1

    http://boss.bekk.no/boss/middlegen/
    http://www.hibernate.org/
-->

<sql-query name="loyaltyProgramReport">
	<return-scalar column="cust_no" 			type="string"/>
	<return-scalar column="account_name" 		type="string"/>
	<return-scalar column="product_types"		type="string"/>
	<return-scalar column="value_per_point"		type="string"/>
	<return-scalar column="balance"				type="string"/>
	<return-scalar column="balance_value"		type="string"/>
	<return-scalar column="award"				type="string"/>
	<return-scalar column="award_value"			type="string"/>
	<return-scalar column="adjusted"			type="string"/>
	<return-scalar column="adjusted_value"		type="string"/>
	<return-scalar column="redeem"				type="string"/>
	<return-scalar column="redeem_value"		type="string"/>
	<return-scalar column="expired"				type="string"/>
	<return-scalar column="expired_value"		type="string"/>
	<return-scalar column="closing"				type="string"/>
	<return-scalar column="closing_value"		type="string"/>
	<return-scalar column="cut_off_dt"			type="string"/>
	<return-scalar column="expire_dt"			type="string"/>
	<return-scalar column="created_dt"			type="string"/>
	<return-scalar column="effective_dt"		type="string"/>
	<return-scalar column="acct_status"			type="string"/>
	<return-scalar column="contact_name"		type="string"/>
	<return-scalar column="contacts"			type="string"/>
	<return-scalar column="faxs"				type="string"/>
	<return-scalar column="emails"				type="string"/>
	<return-scalar column="address_block"		type="string"/>
	<return-scalar column="address_street"		type="string"/>
	<return-scalar column="address_unit"		type="string"/>
	<return-scalar column="address_building"	type="string"/>
	<return-scalar column="address_area"		type="string"/>
	<return-scalar column="address_postal"		type="string"/>
	<return-scalar column="name"				type="string"/>
	<![CDATA[
select
    acct.CUST_NO,
    acct.ACCOUNT_NAME,
    subscriptions.product_types,
    value_per_point.master_value as value_per_point,
    trim(to_char(nvl(reward_balance.balance, 0), '99,999,990')) as balance,
    trim(to_char(nvl(reward_balance.balance, 0) * value_per_point.master_value, '99,999,990.00')) as balance_value,
    trim(to_char(nvl(current_award.award, 0), '99,999,990')) as award,
    trim(to_char(nvl(current_award.award, 0) * value_per_point.master_value, '99,999,990.00')) as award_value,
    trim(to_char(nvl(current_adjustment.adjusted, 0), '99,999,990')) as adjusted,
    trim(to_char(nvl(current_adjustment.adjusted, 0) * value_per_point.master_value, '99,999,990.00')) as adjusted_value,
    trim(to_char(nvl(current_redeem.redeem, 0), '99,999,990')) as redeem,
    trim(to_char(nvl(current_redeem.redeem, 0) * value_per_point.master_value, '99,999,990.00')) as redeem_value,
    trim(to_char(case when current_status.ACCT_STATUS = 'C' or reward_acct.EXPIRE_DT < case when :pointEnd is null then to_timestamp(to_char(last_day(to_date(:pointStart, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') else to_timestamp(to_char(last_day(to_date(:pointEnd, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') end then (nvl(reward_balance.balance, 0) + nvl(current_award.award, 0) - nvl(current_redeem.redeem, 0) + nvl(current_adjustment.adjusted, 0)) else 0 end, '99,999,990')) as expired,
    trim(to_char(case when current_status.ACCT_STATUS = 'C' or reward_acct.EXPIRE_DT < case when :pointEnd is null then to_timestamp(to_char(last_day(to_date(:pointStart, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') else to_timestamp(to_char(last_day(to_date(:pointEnd, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') end then (nvl(reward_balance.balance, 0) + nvl(current_award.award, 0) - nvl(current_redeem.redeem, 0) + nvl(current_adjustment.adjusted, 0)) else 0 end * value_per_point.master_value, '99,999,990.00')) as expired_value,
    trim(to_char(case when current_status.ACCT_STATUS = 'C' or reward_acct.EXPIRE_DT < case when :pointEnd is null then to_timestamp(to_char(last_day(to_date(:pointStart, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') else to_timestamp(to_char(last_day(to_date(:pointEnd, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') end then 0 else (nvl(reward_balance.balance, 0) + nvl(current_award.award, 0) - nvl(current_redeem.redeem, 0) + nvl(current_adjustment.adjusted, 0)) end, '99,999,990')) as closing,
    trim(to_char(case when current_status.ACCT_STATUS = 'C' or reward_acct.EXPIRE_DT < case when :pointEnd is null then to_timestamp(to_char(last_day(to_date(:pointStart, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') else to_timestamp(to_char(last_day(to_date(:pointEnd, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') end then 0 else (nvl(reward_balance.balance, 0) + nvl(current_award.award, 0) - nvl(current_redeem.redeem, 0) + nvl(current_adjustment.adjusted, 0)) end * value_per_point.master_value, '99,999,990.00')) as closing_value,
    to_char(reward_acct.CUT_OFF_DT, 'dd/mm/yyyy') as CUT_OFF_DT,
    to_char(reward_acct.EXPIRE_DT, 'dd/mm/yyyy') as EXPIRE_DT,
    to_char(acct.CREATED_DT, 'dd/mm/yyyy') as CREATED_DT,
    to_char(t_status.EFFECTIVE_DT, 'dd/mm/yyyy') as EFFECTIVE_DT,
    current_status.ACCT_STATUS,
    case when main_sal.MASTER_NO is not null then main_sal.MASTER_VALUE||' ' else '' end || contact.MAIN_CONTACT_NAME || case when contact.MAIN_CONTACT_NAME is not null and contact.SUB_CONTACT_NAME is not null then ' / ' else '' end || case when contact.SUB_CONTACT_NAME is not null then case when sub_sal.MASTER_NO is not null then sub_sal.MASTER_VALUE||' ' else '' end || contact.SUB_CONTACT_NAME else '' end as contact_name,
    contact.MAIN_CONTACT_TEL || case when contact.MAIN_CONTACT_MOBILE is not null then ', '||contact.MAIN_CONTACT_MOBILE else '' end || case when contact.SUB_CONTACT_TEL is not null or contact.SUB_CONTACT_MOBILE is not null then ' / '||nvl(contact.SUB_CONTACT_TEL, '')||case when contact.SUB_CONTACT_TEL is not null and contact.SUB_CONTACT_MOBILE is not null then ', ' else '' end||nvl(contact.SUB_CONTACT_MOBILE, '') else '' end as contacts,
    contact.MAIN_CONTACT_FAX || case when contact.SUB_CONTACT_FAX is not null then ' / ' else '' end || nvl(contact.SUB_CONTACT_FAX, '') as faxs,
    contact.MAIN_CONTACT_EMAIL || case when contact.SUB_CONTACT_EMAIL is not null then ' / ' else '' end || nvl(contact.SUB_CONTACT_EMAIL, '') as emails,
    contact.ADDRESS_BLOCK, contact.ADDRESS_STREET, contact.ADDRESS_UNIT, contact.ADDRESS_BUILDING, contact.ADDRESS_AREA, contact.ADDRESS_POSTAL,
    sales.NAME from LRTB_REWARD_ACCOUNT reward_acct
    inner join AMTB_ACCOUNT acct on reward_acct.ACCOUNT_NO = acct.ACCOUNT_NO
    inner join FMTB_AR_CONT_CODE_MASTER ar on ar.ar_control_code_no = acct.ar_control_code_no
	inner join FMTB_ENTITY_MASTER entity on ar.entity_no =entity.entity_no
    left join AMTB_ACCT_STATUS t_status on acct.ACCOUNT_NO = t_status.ACCOUNT_NO and t_status.ACCT_STATUS = 'T'
    inner join (
select ACCOUNT_NO, max(EFFECTIVE_DT) as last_effective_dt from AMTB_ACCT_STATUS where effective_dt < current_timestamp group by account_no
    ) acct_last_status on acct.ACCOUNT_NO = acct_last_status.ACCOUNT_NO
    inner join AMTB_ACCT_STATUS current_status on acct.ACCOUNT_NO = current_status.ACCOUNT_NO and current_status.EFFECTIVE_DT = acct_last_status.last_effective_dt and (:acctStatus is null or current_status.ACCT_STATUS = :acctStatus)
    left join (
select ACCOUNT_NO, listagg(PRODUCT_TYPE_ID, ',') within group(order by product_type_id) as product_types from AMTB_SUBSC_TO where REWARD_PLAN_NO is not null group by ACCOUNT_NO
    ) subscriptions on acct.ACCOUNT_NO = subscriptions.ACCOUNT_NO
    left join AMTB_ACCT_MAIN_CONTACT main_contact on acct.ACCOUNT_NO = main_contact.ACCOUNT_NO and main_contact.MAIN_CONTACT_TYPE = 'S'
    left join AMTB_CONTACT_PERSON contact on main_contact.CONTACT_PERSON_NO = contact.CONTACT_PERSON_NO
    left join MSTB_MASTER_TABLE main_sal on contact.MAIN_CONTACT_SAL = main_sal.MASTER_NO
    left join MSTB_MASTER_TABLE sub_sal on contact.SUB_CONTACT_SAL = sub_sal.MASTER_NO
    inner join MSTB_MASTER_TABLE value_per_point on value_per_point.MASTER_TYPE = 'RPPR'
    inner join (
select ACCOUNT_NO, max(effective_dt_from) as last_effective_dt_from from AMTB_ACCT_SALESPERSON where EFFECTIVE_DT_FROM < current_timestamp group by ACCOUNT_NO
    ) last_sales on acct.ACCOUNT_NO = last_sales.ACCOUNT_NO
    inner join AMTB_ACCT_SALESPERSON acct_sales on acct.ACCOUNT_NO = acct_sales.ACCOUNT_NO and acct_sales.EFFECTIVE_DT_FROM = last_sales.last_effective_dt_from
    inner join MSTB_SALESPERSON sales on sales.SALESPERSON_NO = acct_sales.SALESPERSON_NO
    left join (
select txn.REWARD_ACCOUNT_NO, sum(rewards_pts) as balance from lrtb_reward_txn txn inner join LRTB_REWARD_ACCOUNT reward_acct on txn.REWARD_ACCOUNT_NO = reward_acct.REWARD_ACCOUNT_NO and reward_acct.EXPIRE_DT > to_timestamp(substr(:pointStart, 0, 8)||'01 00:00:00', 'yyyy-mm-dd hh24:mi:ss') left join BMTB_INVOICE_HEADER header on txn.INVOICE_HEADER_NO = header.INVOICE_HEADER_NO where 
	-- to exclude out forefit txns-- 
   	(
   		-- bill gen awarded pts--
   		(txn.GIFT_STOCK_NO is null and txn.CONTACT_PERSON_NO is null and txn.ADJ_REQ_NO is null and txn.REWARDS_PTS >= 0)
    	OR
    	--adjustment or redemption--
   		(txn.gift_stock_no is not null or txn.contact_person_no is not null or txn.adj_req_no is not null) 
    )
    and
	case when txn.created_dt is null then header.CREATED_DT else txn.created_dt end < to_timestamp(substr(:pointStart, 0, 8)||'01 00:00:00', 'yyyy-mm-dd hh24:mi:ss') group by txn.REWARD_ACCOUNT_NO
    ) reward_balance on reward_acct.REWARD_ACCOUNT_NO = reward_balance.REWARD_ACCOUNT_NO
    left join (
select REWARD_ACCOUNT_NO, sum(rewards_pts) as award from lrtb_reward_txn txn left join BMTB_INVOICE_HEADER header on txn.INVOICE_HEADER_NO = header.INVOICE_HEADER_NO where adj_req_no is null and rewards_pts > 0 and case when txn.created_dt is null then header.CREATED_DT else txn.created_dt end between to_timestamp(substr(:pointStart, 0, 8)||'01 00:00:00', 'yyyy-mm-dd hh24:mi:ss') and case when :pointEnd is null then to_timestamp(to_char(last_day(to_date(:pointStart, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') else to_timestamp(to_char(last_day(to_date(:pointEnd, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') end group by REWARD_ACCOUNT_NO
    ) current_award on reward_acct.REWARD_ACCOUNT_NO = current_award.REWARD_ACCOUNT_NO
    left join (
select REWARD_ACCOUNT_NO, sum(-rewards_pts) as redeem from lrtb_reward_txn txn inner join LRTB_GIFT_STOCK gift on txn.GIFT_STOCK_NO = gift.GIFT_STOCK_NO left join BMTB_INVOICE_HEADER header on txn.INVOICE_HEADER_NO = header.INVOICE_HEADER_NO where adj_req_no is null and rewards_pts < 0 and case when txn.created_dt is null then header.CREATED_DT else txn.created_dt end between to_timestamp(substr(:pointStart, 0, 8)||'01 00:00:00', 'yyyy-mm-dd hh24:mi:ss') and case when :pointEnd is null then to_timestamp(to_char(last_day(to_date(:pointStart, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') else to_timestamp(to_char(last_day(to_date(:pointEnd, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') end group by REWARD_ACCOUNT_NO
    ) current_redeem on reward_acct.REWARD_ACCOUNT_NO = current_redeem.REWARD_ACCOUNT_NO
    left join (
    select REWARD_ACCOUNT_NO, sum(rewards_pts) as adjusted from lrtb_reward_txn txn where adj_req_no is not null and txn.created_dt between to_timestamp(substr(:pointStart, 0, 8)||'01 00:00:00', 'yyyy-mm-dd hh24:mi:ss') and case when :pointEnd is null then to_timestamp(to_char(last_day(to_date(:pointStart, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') else to_timestamp(to_char(last_day(to_date(:pointEnd, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') end group by REWARD_ACCOUNT_NO
    ) current_adjustment on reward_acct.REWARD_ACCOUNT_NO = current_adjustment.REWARD_ACCOUNT_NO
    where (reward_balance.balance is not null or current_award.award is not null or current_redeem.redeem is not null or current_adjustment.adjusted is not null)
    and (:acctTypeNo is null or acct.ACCT_TYPE_NO = :acctTypeNo)
    and acct.CUST_NO like :acctNo
    and acct.ACCOUNT_NAME like :acctName
    and (:productTypeId is null or subscriptions.PRODUCT_TYPES like :productTypeId)
    and (:salespersonNo is null or sales.SALESPERSON_NO = :salespersonNo)
    and (:entityNo is null or entity.entity_no = :entityNo)
    order by case when :sort = 'AN' then acct.ACCOUNT_NAME else null end, case when :sort = 'CB' then case when current_status.ACCT_STATUS = 'C' or reward_acct.EXPIRE_DT < case when :pointEnd is null then to_timestamp(to_char(last_day(to_date(:pointStart, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') else to_timestamp(to_char(last_day(to_date(:pointEnd, 'yyyy-mm-dd')),'yyyy-mm-dd')||' 23:59:59', 'yyyy-mm-dd hh24:mi:ss') end then 0 else (nvl(reward_balance.balance, 0) + nvl(current_award.award, 0) - nvl(current_redeem.redeem, 0) + nvl(current_adjustment.adjusted, 0)) end else null end
	]]>
</sql-query>
</hibernate-mapping>