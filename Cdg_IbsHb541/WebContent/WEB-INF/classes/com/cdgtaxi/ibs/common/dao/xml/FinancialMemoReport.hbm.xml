<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN" 
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
    
<hibernate-mapping>
<!-- 
    Created by the Middlegen Hibernate plugin 2.1

    http://boss.bekk.no/boss/middlegen/
    http://www.hibernate.org/
-->

<sql-query name="financialMemoReport">
	<return-scalar column="cust_no" 		type="string"/>
	<return-scalar column="account_name" 	type="string"/>
	<return-scalar column="invoice_nos"		type="string"/>
	<return-scalar column="receipt_nos"		type="string"/>
	<return-scalar column="memo_no"			type="string"/>
	<return-scalar column="memo_dt"			type="string"/>
	<return-scalar column="received_amt"	type="string"/>
	<return-scalar column="applied_amt"		type="string"/>
	<return-scalar column="balance_amt"		type="string"/>
	<return-scalar column="offset_amt"		type="string"/>
	<return-scalar column="refund_amt"		type="string"/>
	<return-scalar column="type"			type="string"/>
	<return-scalar column="cheque_no"		type="string"/>
	<return-scalar column="updated_dt"		type="string"/>
	<![CDATA[
select main.CUST_NO, main.ACCOUNT_NAME, main.INVOICE_NOS,
	trim(to_char(main.RECEIPT_NOS, '999999990')) as RECEIPT_NOS,
	trim(to_char(main.MEMO_NO, '999999990')) as MEMO_NO,
	to_char(main.MEMO_DT, 'dd/mm/yyyy') as MEMO_DT, 
	trim(to_char(main.RECEIVED_AMT, '999,999,990.00')) as RECEIVED_AMT,
	trim(to_char(main.APPLIED_AMT, '999,999,990.00')) as APPLIED_AMT,
	trim(to_char(main.BALANCE_AMT, '999,999,990.00')) as BALANCE_AMT,
	trim(to_char(main.OFFSET_AMT, '999,999,990.00')) as OFFSET_AMT,
	trim(to_char(main.REFUND_AMT, '999,999,990.00')) as REFUND_AMT,
	main.TYPE, main.CHEQUE_NO,
	to_char(main.UPDATED_DT, 'dd/mm/yyyy') as UPDATED_DT 
	from (
select acct.CUST_NO, acct.ACCOUNT_NAME, replace(deposit.invoice_nos, ',',',
') as invoice_nos, null as receipt_nos, refund.PAYMENT_RECEIPT_NO as memo_no, refund.RECEIPT_DT as memo_dt,
    deposit.RECEIVED_AMT, deposit.APPLIED_AMT, deposit.BALANCE_AMT, deposit.RECEIVED_AMT - refund.REFUND_AMT as OFFSET_AMT, refund.REFUND_AMT,
    'DEPOSIT' as type, refund.CHEQUE_NO, refund.UPDATED_DT from AMTB_ACCOUNT acct
    inner join (
select txn.ACCOUNT_NO, receipt.PAYMENT_RECEIPT_NO, receipt.RECEIPT_DT, receipt.PAYMENT_AMOUNT as refund_amt, receipt.CHEQUE_NO, receipt.UPDATED_DT
    from BMTB_INVOICE_DEPOSIT_TXN txn
    inner join BMTB_PAYMENT_RECEIPT receipt on txn.PAYMENT_RECEIPT_NO = receipt.PAYMENT_RECEIPT_NO
) refund on refund.ACCOUNT_NO = acct.ACCOUNT_NO
    inner join (
select deposit.ACCOUNT_NO, 
cast(listagg(header.invoice_no,',') within group (order by header.invoice_no) as varchar2(4000)) as invoice_nos,
sum(header.NEW_TXN) as received_amt, sum(header.NEW_TXN) - sum(header.OUTSTANDING_AMOUNT) as applied_amt,
    sum(header.OUTSTANDING_AMOUNT) as balance_amt
    from BMTB_INVOICE_DEPOSIT_TXN deposit
    inner join BMTB_INVOICE_HEADER header on deposit.INVOICE_HEADER_NO = header.INVOICE_HEADER_NO
    group by deposit.ACCOUNT_NO
) deposit on deposit.ACCOUNT_NO = acct.ACCOUNT_NO
 	inner join FMTB_AR_CONT_CODE_MASTER ar on ar.ar_control_code_no = acct.ar_control_code_no
    inner join FMTB_ENTITY_MASTER entity on ar.entity_no =entity.entity_no and (:entityNo is null or entity.entity_no = :entityNo)
union
select acct.CUST_NO, acct.ACCOUNT_NAME, null, receipt.PAYMENT_RECEIPT_NO, memo.PAYMENT_RECEIPT_NO, memo.RECEIPT_DT, receipt.PAYMENT_AMOUNT, receipt.PAYMENT_AMOUNT - memo.PAYMENT_AMOUNT, memo.PAYMENT_AMOUNT, 0,
    memo.PAYMENT_AMOUNT, 'EXCESS', memo.CHEQUE_NO, memo.UPDATED_DT
    from BMTB_PAYMENT_RECEIPT receipt
    inner join BMTB_PAYMENT_RECEIPT memo on receipt.MEMO_RECEIPT_NO = memo.PAYMENT_RECEIPT_NO
    inner join AMTB_ACCOUNT acct on acct.ACCOUNT_NO = receipt.ACCOUNT_NO
    inner join FMTB_AR_CONT_CODE_MASTER ar on ar.ar_control_code_no = acct.ar_control_code_no
    inner join FMTB_ENTITY_MASTER entity on ar.entity_no =entity.entity_no and (:entityNo is null or entity.entity_no = :entityNo)
) main
    where main.CUST_NO like :acctNo and main.ACCOUNT_NAME like :acctName
    and ((:memoStart is null and :memoEnd is null)or(main.MEMO_DT between case when :memoStart is null then to_date(:memoEnd, 'yyyy-mm-dd hh24:mi:ss') else to_date(:memoStart, 'yyyy-mm-dd hh24:mi:ss') end and case when :memoEnd is null then to_date(:memoStart, 'yyyy-mm-dd hh24:mi:ss') else to_date(:memoEnd, 'yyyy-mm-dd hh24:mi:ss') end))
    and (:memoNo is null or main.MEMO_NO = :memoNo)
    and (:invoiceNo is null or (','||main.INVOICE_NOS||',') like :invoiceNo)
    and (:receiptNo is null or main.RECEIPT_NOS = :receiptNo)
    and (:memoType is null or main.type = :memoType)
    order by case when :sort = 'MN' then main.MEMO_NO else null end, main.MEMO_DT
	]]>
</sql-query>
</hibernate-mapping>