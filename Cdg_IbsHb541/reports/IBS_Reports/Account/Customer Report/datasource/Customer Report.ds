<?xml version="1.0" encoding="UTF-8"?>
<ds:datasource xmlns:ds="http://www.elixirtech.com/DataSource" name="Customer Report" type="JDBC" path="/IBS_Reports/Account/Customer Report/datasource/Customer Report.ds" description="">
  <ds:schema case-sensitive="Yes">
    <ds:column name="CUST_NO" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="ACCOUNT_NO" type="Double">
      <ds:attribute name="Nullable" nullable="no" />
    </ds:column>
    <ds:column name="ACCOUNT_NAME" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="SUBSCRIBED_PRODUCT_TYPE" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MASTER_VALUE" type="String">
      <ds:attribute name="Nullable" nullable="no" />
    </ds:column>
    <ds:column name="CREATED_DT" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="EFFECTIVE_DT" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="ACCT_STATUS" type="String">
      <ds:attribute name="Nullable" nullable="no" />
    </ds:column>
    <ds:column name="CREDIT_LIMIT" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="CREDIT_BALANCE" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_CONTACT_NAME" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_CONTACT_NO" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_CONTACT_FAX" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_CONTACT_EMAIL" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_ADDRESS_AREA" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_ADDRESS_BLOCK" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_ADDRESS_STREET" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_ADDRESS_UNIT" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_ADDRESS_BUILDING" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_ADDRESS_COUNTRY" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_ADDRESS_STATE" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_ADDRESS_CITY" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="MAIN_ADDRESS_POSTAL" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="BILLING_CYCLE" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="NAME" type="String">
      <ds:attribute name="Nullable" nullable="no" />
    </ds:column>
    <ds:column name="E_INVOICE_FLAG" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="OUTSOURCE_PRINTING_FLAG" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="ACE_INDICATOR" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="PUBBS_FLAG" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="FI_FLAG" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="TOTAL_INVOICE_AMOUNT" type="Double">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="PRODUCT_TYPES" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="CREDIT_TERM_PLAN_NAME" type="String">
      <ds:attribute name="Nullable" nullable="no" />
    </ds:column>
    <ds:column name="EARLY_PAYMENT_PLAN_NAME" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="LATE_PAYMENT_PLAN_NAME" type="String">
      <ds:attribute name="Nullable" nullable="no" />
    </ds:column>
    <ds:column name="VOLUME_DISCOUNT_PLAN_NAME" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="PROMO_NAME" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="TRIP_START_DT" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="PRODUCT_TYPE_ID" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="AD_FEE" type="String">
      <ds:attribute name="Nullable" nullable="no" />
    </ds:column>
    <ds:column name="BANK_ACCT_NO" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="BANK" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="BRANCH" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="PAYMENT_MODE" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
    <ds:column name="GOVT_EINV_FLAGGED" type="String">
      <ds:attribute name="Nullable" nullable="yes" />
    </ds:column>
  </ds:schema>
  <ds:security name="" />
  <ds:jdbc connection-type="POOL" connection-pool="/IBS_Reports/ConnectionPool/IBS Connection Pool.pool" connection-pool-timeout="0" callable-statement="No" connection-reuse="0" nulls-to-strings="No" read-only="Yes" auto-commit="Yes">
    <ds:sql>select
		temp.*,
		last_invoice.total_invoice_amount, 
		subscriptions.product_types, credit_term.CREDIT_TERM_PLAN_NAME,
		early_pymt.EARLY_PAYMENT_PLAN_NAME, late_pymt.LATE_PAYMENT_PLAN_NAME, vol_dis.VOLUME_DISCOUNT_PLAN_NAME, promo.PROMO_NAME,
		to_char(last_txn.trip_start_dt, 'dd/mm/yyyy') as trip_start_dt, last_txn.product_type_id,
		temp_extra.ad_fee,temp_extra.bank_acct_no,temp_extra.bank,temp_extra.branch,temp_extra.payment_mode,
		case when govt_einv.VALUE is null then 'NO' else 'YES' end as GOVT_EINV_FLAGGED
	FROM(
		select
			distinct(acct.CUST_NO), 
			acct.account_no,
			acct.ACCOUNT_NAME, 
			subscribed.subscribed_product_type,
			industry.master_value, 
			to_char(acct.CREATED_DT, 'dd/mm/yyyy') as created_dt, 
			to_char(case when t_status.effective_dt is not null then t_status.effective_dt else c_status.effective_dt end, 'dd/mm/yyyy') as effective_dt, 
			status.acct_status, 
			trim(to_char(acct.credit_limit, '999,999,990.00')) as credit_limit, 
			trim(to_char(acct.credit_balance, '999,999,990.00')) as credit_balance,
			case when contact.main_contact_sal is not null then main_sal.master_value || ' ' else '' end || contact.main_contact_name || case when contact.sub_contact_name is not null then ' / ' || case when contact.sub_contact_sal is not null then sub_sal.master_value || ' ' else '' end || contact.sub_contact_name else '' end as main_contact_name,
			contact.main_contact_tel || case when contact.main_contact_fax is not null then ', ' || contact.main_contact_fax else '' end as main_contact_no,
			contact.main_contact_fax, contact.main_contact_email,
		    	--address
		    (case when contact.address_area is NULL then '' else contact.address_area End ) as main_address_area
		        ,
		    (case when contact.address_block is NULL then '' else contact.address_block End ) as main_address_block
		        ,
		    (case when contact.address_street is NULL then '' else contact.address_street End ) as main_address_street
		        ,
		    (case when contact.address_unit is NULL then '' else  contact.address_unit End ) as main_address_unit
		        ,
		    (case when contact.address_building is NULL then '' else contact.address_building End ) as main_address_building
		        ,
		    (case when contact.address_country is NULL then '' else contact_country.master_value End ) as main_address_country
		        ,
		    (case when contact.address_state is NULL then '' else  contact.address_state End ) as main_address_state
		        ,
		    (case when contact.address_city is NULL then '' else  contact.address_city End ) as main_address_city
		        ,
		    (case when contact.address_postal is NULL then '' else contact.address_postal End ) as main_address_postal,
		    bill_cycle.BILLING_CYCLE,
		    sales.NAME, 
		    acct.E_INVOICE_FLAG, case when acct.OUTSOURCE_PRINTING_FLAG is null then 'NO' 
		    	 when acct.OUTSOURCE_PRINTING_FLAG = 'N' then 'NO' else 'YES' end as OUTSOURCE_PRINTING_FLAG, acct.ace_indicator as ace_indicator,
case when acct.pubbs_flag is null then 'NO' 
		    	 when acct.pubbs_flag = 'N' then 'NO' else 'YES' end as pubbs_flag,
		 	case when acct.fi_flag is null then 'NO' 
		    	 when acct.fi_flag = 'N' then 'NO' else 'YES' end as fi_flag
		    from AMTB_ACCOUNT acct
		    inner join (
		    		select cast (listagg(PRODUCT_TYPE_ID, ',') within group(order by product_type_id) as varchar2(4000)) as subscribed_product_type, account_no
		    		from AMTB_SUBSC_TO where account_no in (
		    			select account_no from AMTB_SUBSC_TO 
		    			where ('${04. Subscribed Product Type#choice()#MASTER:PT}' is null or PRODUCT_TYPE_ID = '${04. Subscribed Product Type#choice()#MASTER:PT}')
		    		) group by ACCOUNT_NO
		    	) subscribed on subscribed.ACCOUNT_NO = acct.ACCOUNT_NO 
		    		and acct.CUST_NO is not null 
		    		and acct.CUST_NO like '%${02a. Account No#acctsearch#custId}%' 
		    		and acct.ACCOUNT_NAME like '%${02b. Account Name#acctsearch#custName}%'  
		    		and (
		    			('${06. Join Start Date#date}' is null and '${07. Join End Date#date}' is null)
		    			or(acct.CREATED_DT between 
		    				case when '${06. Join Start Date#date}' is null then to_date('${07. Join End Date#date}', 'yyyy-mm-dd hh24:mi:ss') 
		    				else to_date('${06. Join Start Date#date}', 'yyyy-mm-dd hh24:mi:ss') end 
		    				and 
		    				case when '${07. Join End Date#date}' is null then to_date('${06. Join Start Date#date}', 'yyyy-mm-dd hh24:mi:ss')
		    				else to_date('${07. Join End Date#date}', 'yyyy-mm-dd hh24:mi:ss') end)
		    			)
		    inner join AMTB_ACCT_TYPE type on acct.ACCT_TYPE_NO = type.ACCT_TYPE_NO and type.ACCT_TYPE_NO in (select acct_type_no from AMTB_ACCT_TYPE where ACCT_TEMPLATE like '%${01. Account Type#choice()#NC:ACCOUNT_TYPE:REQUIRED}%')
		    left join AMTB_CORPORATE_DETAIL corp_details on corp_details.ACCOUNT_NO = acct.ACCOUNT_NO
		    left join AMTB_PERSONAL_DETAIL pers_details on pers_details.ACCOUNT_NO = acct.ACCOUNT_NO
		    inner join MSTB_MASTER_TABLE industry on case when corp_details.INDUSTRY is not null then corp_details.INDUSTRY else pers_details.INDUSTRY end = industry.MASTER_NO and ('${05. Business Nature#choice()#choice()#CC:IND}' is null or (industry.MASTER_CODE = '${05. Business Nature#choice()#choice()#CC:IND}' and industry.MASTER_TYPE = 'IND'))
		    left join AMTB_ACCT_STATUS t_status on t_status.ACCOUNT_NO = acct.ACCOUNT_NO and t_status.ACCT_STATUS = 'T'
		    left join AMTB_ACCT_STATUS c_status on c_status.ACCOUNT_NO = acct.ACCOUNT_NO and c_status.ACCT_STATUS = 'C'
		    inner join (select max(EFFECTIVE_DT) as effective_dt, account_no from AMTB_ACCT_STATUS where EFFECTIVE_DT &lt; systimestamp group by account_no) last_eff_status on last_eff_status.account_no = acct.account_no
		    inner join AMTB_ACCT_STATUS status on last_eff_status.effective_dt = status.effective_dt and status.account_no = acct.account_no and ('${03. Account Status#choice()#NC:ACCOUNT_STATUS}' is null or status.ACCT_STATUS = '${03. Account Status#choice()#NC:ACCOUNT_STATUS}')
		    left join AMTB_ACCT_MAIN_CONTACT main on main.ACCOUNT_NO = acct.ACCOUNT_NO and main.MAIN_CONTACT_TYPE = 'S'
		    left join AMTB_CONTACT_PERSON contact on main.CONTACT_PERSON_NO = contact.CONTACT_PERSON_NO
		    left join MSTB_MASTER_TABLE contact_country on contact.ADDRESS_COUNTRY = contact_country.MASTER_NO
		    left join MSTB_MASTER_TABLE main_sal on contact.main_contact_sal = main_sal.master_no
		    left join MSTB_MASTER_TABLE sub_sal on contact.sub_contact_sal = sub_sal.master_no
		    left join (select max(EFFECTIVE_DATE) as effective_date, account_no from AMTB_ACCT_BILL_CYCLE group by account_no) last_eff_bill_cycle on last_eff_bill_cycle.account_no = acct.account_no
		    left join AMTB_ACCT_BILL_CYCLE bill_cycle on last_eff_bill_cycle.effective_date = bill_cycle.effective_date and bill_cycle.account_no = acct.account_no
		    inner join (
				select ACCOUNT_NO, max(EFFECTIVE_DT_FROM) as last_effective_dt_from from AMTB_ACCT_SALESPERSON where effective_dt_from &lt; systimestamp group by ACCOUNT_NO
		    ) last_acct_sales on acct.ACCOUNT_NO = last_acct_sales.ACCOUNT_NO
		    inner join AMTB_ACCT_SALESPERSON acct_sales on acct.account_no = acct_sales.account_no and last_acct_sales.LAST_EFFECTIVE_DT_FROM = acct_sales.EFFECTIVE_DT_FROM and ((acct_sales.EFFECTIVE_DT_FROM &lt; systimestamp and acct_sales.EFFECTIVE_DT_TO IS null) OR systimestamp between acct_sales.EFFECTIVE_DT_FROM and acct_sales.EFFECTIVE_DT_TO)
		    inner join MSTB_SALESPERSON sales on acct_sales.SALESPERSON_NO = sales.SALESPERSON_NO
		    inner join FMTB_AR_CONT_CODE_MASTER ar on acct.AR_CONTROL_CODE_NO = ar.AR_CONTROL_CODE_NO
		    inner join FMTB_ENTITY_MASTER entity on ar.entity_no = entity.entity_no
		    --WHERE CLAUSE
		    where (
		        (('${08. Terminated Start Date#date}' is null and '${09. Terminated End Date#date}' is null)or(t_status.effective_dt between case when '${08. Terminated Start Date#date}' is null then to_date('${09. Terminated End Date#date}', 'yyyy-mm-dd hh24:mi:ss') else to_date('${08. Terminated Start Date#date}', 'yyyy-mm-dd hh24:mi:ss') end and case when '${09. Terminated End Date#date}' is null then to_date('${08. Terminated Start Date#date}', 'yyyy-mm-dd hh24:mi:ss') else to_date('${09. Terminated End Date#date}', 'yyyy-mm-dd hh24:mi:ss') end)) or
		        (('${08. Terminated Start Date#date}' is null and '${09. Terminated End Date#date}' is null)or(c_status.effective_dt between case when '${08. Terminated Start Date#date}' is null then to_date('${09. Terminated End Date#date}', 'yyyy-mm-dd hh24:mi:ss') else to_date('${08. Terminated Start Date#date}', 'yyyy-mm-dd hh24:mi:ss') end and case when '${09. Terminated End Date#date}' is null then to_date('${08. Terminated Start Date#date}', 'yyyy-mm-dd hh24:mi:ss') else to_date('${09. Terminated End Date#date}', 'yyyy-mm-dd hh24:mi:ss') end))
		    )
		    and ('${10. Sales Person#choice()#MASTER:SP}' is null or sales.SALESPERSON_NO = '${10. Sales Person#choice()#MASTER:SP}')
		    and ('${12. Entity#choice(1,2,3)#MASTER:EM}' is null or entity.entity_no = '${12. Entity#choice(1,2,3)#MASTER:EM}')
	) temp
		--Last Invoice
	    left join (
	        select top.ACCOUNT_NO, sum(header.NEW_TXN) as total_invoice_amount
	            from BMTB_INVOICE_HEADER header
	            left join AMTB_ACCOUNT acct on header.debt_to = acct.ACCOUNT_NO
	            left join AMTB_ACCOUNT parent on acct.PARENT_NO = parent.ACCOUNT_NO
	            left join AMTB_ACCOUNT grand on parent.PARENT_NO = grand.ACCOUNT_NO
	            inner join AMTB_ACCOUNT top on (case when grand.cust_no is not null then grand.account_no when parent.cust_no is not null then parent.account_no else acct.account_no end) = top.account_no
	            inner join AMTB_ACCT_TYPE type on top.ACCT_TYPE_NO = type.ACCT_TYPE_NO
	            where header.NEW_TXN != 0 AND header.INVOICE_FORMAT in ('A','S','P')
	            AND exists (
	                select 1
	                    from (
	                        select distinct top.ACCOUNT_NO, first_value(sq_header.INVOICE_DATE) over (Partition by top.ACCOUNT_NO order by sq_header.INVOICE_DATE desc) as INVOICE_DATE 
                                  from BMTB_INVOICE_HEADER sq_header
                                  left join AMTB_ACCOUNT acct on sq_header.debt_to = acct.ACCOUNT_NO 
                                  left join AMTB_ACCOUNT parent on acct.PARENT_NO = parent.ACCOUNT_NO 
                                  left join AMTB_ACCOUNT grand on parent.PARENT_NO = grand.ACCOUNT_NO 
                                  inner join AMTB_ACCOUNT top on (case when grand.cust_no is not null then grand.account_no when parent.cust_no is not null then parent.account_no else acct.account_no end) = top.account_no
	                    ) temp
	                    where temp.ACCOUNT_NO = top.ACCOUNT_NO and temp.INVOICE_DATE = header.INVOICE_DATE
	            )
	            AND exists (
	              		select acct_type_no
	              		from AMTB_ACCT_TYPE 
	              		where type.ACCT_TYPE_NO = ACCT_TYPE_NO AND ACCT_TEMPLATE like '%${01. Account Type#choice()#NC:ACCOUNT_TYPE:REQUIRED}%'
	              )
	            group by top.ACCOUNT_NO
	    ) last_invoice on last_invoice.ACCOUNT_NO = temp.account_no
		--transactions
		left join(
			select 
				distinct top.account_no, 
				first_value(TRIP_START_DT) over (Partition by top.ACCOUNT_NO order by TRIP_START_DT desc) as TRIP_START_DT,
				first_value(PRODUCT_TYPE_ID) over (Partition by top.ACCOUNT_NO order by TRIP_START_DT desc) as PRODUCT_TYPE_ID
			from TMTB_ACQUIRE_TXN txn
			inner join AMTB_ACCOUNT acct on txn.ACCOUNT_NO = acct.ACCOUNT_NO
			left join AMTB_ACCOUNT parent on acct.PARENT_NO = parent.ACCOUNT_NO
			left join AMTB_ACCOUNT grand on parent.PARENT_NO = grand.ACCOUNT_NO
			inner join AMTB_ACCOUNT top on (case when grand.cust_no is not null then grand.account_no when parent.cust_no is not null then parent.account_no else acct.account_no end) = top.account_no
			inner join AMTB_ACCT_TYPE type on top.ACCT_TYPE_NO = type.ACCT_TYPE_NO
			where 
			txn.TRIP_START_DT between sysdate - (365) and sysdate
			AND
			exists (
				select acct_type_no
				from AMTB_ACCT_TYPE 
				where type.ACCT_TYPE_NO = ACCT_TYPE_NO AND ACCT_TEMPLATE like '%${01. Account Type#choice()#NC:ACCOUNT_TYPE:REQUIRED}%'
			)
		) last_txn on last_txn.account_no = temp.account_no
	    --Subscription
	    left join (
			select 
			subscriptions.ACCOUNT_NO, replace(
				listagg(subscriptions.PRODUCT_TYPE_ID || ' - ' ||
	       		case when product_discount_detail.PRODUCT_DISCOUNT is not null then product_discount_detail.PRODUCT_DISCOUNT || '%' else '0%' end ||
	        		case when rewards.REWARD_PLAN_NAME is not null then '(' || rewards.REWARD_PLAN_NAME || ')' else '(NA)' end
	    			, ',') within group(order by subscriptions.product_type_id), ',', ', '
	    		) as product_types 
	    		from AMTB_SUBSC_TO subscriptions
	    		left join MSTB_PROD_DISC_MASTER product_discount on subscriptions.PRODUCT_DISCOUNT_PLAN_NO = product_discount.PRODUCT_DISCOUNT_PLAN_NO
	    		left join (
				select PRODUCT_DISCOUNT_PLAN_NO, max(EFFECTIVE_DT) as max_effective_dt 
				from MSTB_PROD_DISC_DETAIL 
				where EFFECTIVE_DT &lt; current_timestamp 
				group by PRODUCT_DISCOUNT_PLAN_NO
	    		) latest_product_discount_detail on product_discount.PRODUCT_DISCOUNT_PLAN_NO = latest_product_discount_detail.PRODUCT_DISCOUNT_PLAN_NO
	    		left join MSTB_PROD_DISC_DETAIL product_discount_detail on product_discount_detail.PRODUCT_DISCOUNT_PLAN_NO = product_discount.PRODUCT_DISCOUNT_PLAN_NO and product_discount_detail.EFFECTIVE_DT = latest_product_discount_detail.MAX_EFFECTIVE_DT
	    		left join LRTB_REWARD_MASTER rewards on subscriptions.REWARD_PLAN_NO = rewards.REWARD_PLAN_NO
	    		group by subscriptions.ACCOUNT_NO
	    ) subscriptions on subscriptions.ACCOUNT_NO = temp.ACCOUNT_NO
	    --CREDIT TERM
	    inner join (
			select credit_term.ACCOUNT_NO, term_master.CREDIT_TERM_PLAN_NAME
			from AMTB_ACCT_CRED_TERM credit_term
	    		inner join (
				select ACCOUNT_NO, max(EFFECTIVE_DATE) as max_effective_date 
				from AMTB_ACCT_CRED_TERM 
				where EFFECTIVE_DATE &lt; current_timestamp 
				group by ACCOUNT_NO
	    		) last_credit_term on credit_term.ACCOUNT_NO = last_credit_term.ACCOUNT_NO and credit_term.EFFECTIVE_DATE = last_credit_term.MAX_EFFECTIVE_DATE
	    		inner join MSTB_CREDIT_TERM_MASTER term_master on credit_term.CREDIT_TERM_PLAN_NO = term_master.CREDIT_TERM_PLAN_NO
	    ) credit_term on credit_term.ACCOUNT_NO = temp.ACCOUNT_NO
	    --addon default payment mode, bank, branch, bank account no, base admin fee
	    inner join (
			select acct.ACCOUNT_NO
				 ,temp_amtb_admin.plan_no
				 ,mstb_admin_fee.admin_fee_plan_name as ad_fee
				 ,acct.BANK_ACCT_NO
				 ,mstb_bank.BANK_NAME as bank
				 ,mstb_bank_branch.BRANCH_NAME as branch
				 ,mstb_default_pymt.MASTER_VALUE as payment_mode
			from AMTB_ACCOUNT acct 
				left join MSTB_BANK_MASTER mstb_bank on mstb_bank.BANK_MASTER_NO=acct.BANK_MASTER_NO
				left join MSTB_BRANCH_MASTER mstb_bank_branch on mstb_bank_branch.BRANCH_MASTER_NO=acct.BRANCH_MASTER_NO
				left join MSTB_MASTER_TABLE mstb_default_pymt on mstb_default_pymt.MASTER_NO=acct.DEFAULT_PAYMENT_MODE
				inner join (
					SELECT DISTINCT account_no, 
						first_value(ADMIN_FEE_PLAN_NO) OVER (PARTITION BY account_no ORDER BY EFFECTIVE_DATE DESC) AS plan_no
					FROM AMTB_ACCT_ADMIN_FEE
				) temp_amtb_admin on temp_amtb_admin.ACCOUNT_NO=acct.ACCOUNT_NO
				inner join MSTB_ADMIN_FEE_MASTER mstb_admin_fee on mstb_admin_fee.admin_fee_plan_no=temp_amtb_admin.plan_no
	    ) temp_extra on temp_extra.ACCOUNT_NO = temp.ACCOUNT_NO
	    --EARLY PAYMENT
	    left join (
			select early_pymt.ACCOUNT_NO, early_pymt_master.EARLY_PAYMENT_PLAN_NAME 
			from AMTB_ACCT_EARLY_PYMT early_pymt
	    		inner join  (
				select ACCOUNT_NO, max(EFFECTIVE_DATE) as max_effective_date 
				from AMTB_ACCT_EARLY_PYMT 
				where EFFECTIVE_DATE &lt; current_timestamp 
				group by ACCOUNT_NO
	    		) last_early_pymt on early_pymt.ACCOUNT_NO = last_early_pymt.ACCOUNT_NO and early_pymt.EFFECTIVE_DATE = last_early_pymt.MAX_EFFECTIVE_DATE
	    		inner join MSTB_EARLY_PAYMENT_MASTER early_pymt_master on early_pymt.EARLY_PAYMENT_PLAN_NO = early_pymt_master.EARLY_PAYMENT_PLAN_NO
	    ) early_pymt on early_pymt.ACCOUNT_NO = temp.ACCOUNT_NO
	    --LATE PAYMENT
	    inner join (
			select late_pymt.ACCOUNT_NO, late_pymt_master.LATE_PAYMENT_PLAN_NAME 
			from AMTB_ACCT_LATE_PYMT late_pymt
		    	inner join  (
				select ACCOUNT_NO, max(EFFECTIVE_DATE) as max_effective_date 
				from AMTB_ACCT_LATE_PYMT 
				where EFFECTIVE_DATE &lt; current_timestamp 
				group by ACCOUNT_NO
		    	) last_late_pymt on late_pymt.ACCOUNT_NO = last_late_pymt.ACCOUNT_NO and late_pymt.EFFECTIVE_DATE = last_late_pymt.MAX_EFFECTIVE_DATE
	    		inner join MSTB_LATE_PAYMENT_MASTER late_pymt_master on late_pymt.LATE_PAYMENT_PLAN_NO = late_pymt_master.LATE_PAYMENT_PLAN_NO
	    ) late_pymt on late_pymt.ACCOUNT_NO = temp.ACCOUNT_NO
	    --VOLUME DISC
	    left join (
			select vol_dis.ACCOUNT_NO, vol_dis_master.VOLUME_DISCOUNT_PLAN_NAME 
			from AMTB_ACCT_VOL_DISC vol_dis
		    inner join (
				select ACCOUNT_NO, max(EFFECTIVE_DATE) as max_effective_date 
				from AMTB_ACCT_VOL_DISC where EFFECTIVE_DATE &lt; current_timestamp group by ACCOUNT_NO
		    ) last_vol_dis on vol_dis.ACCOUNT_NO = last_vol_dis.ACCOUNT_NO and vol_dis.EFFECTIVE_DATE = last_vol_dis.MAX_EFFECTIVE_DATE
	    		inner join MSTB_VOL_DISC_MASTER vol_dis_master on vol_dis.VOLUME_DISCOUNT_PLAN_NO = vol_dis_master.VOLUME_DISCOUNT_PLAN_NO
	    ) vol_dis on vol_dis.ACCOUNT_NO = temp.ACCOUNT_NO
	    --PROMOTION
	    left join (
			select acct_promo.ACCOUNT_NO, replace(listagg(promo_detail.NAME, ',') within group(order by promo_detail.NAME), ',', ', ') as promo_name
			from AMTB_ACCT_PROMOTION acct_promo
	    		inner join MSTB_PROMOTION promo on acct_promo.PROMO_NO = promo.PROMO_NO
	    		inner join MSTB_PROMO_DETAIL promo_detail on promo_detail.PROMO_NO = promo.PROMO_NO
	    		where acct_promo.EFFECTIVE_DATE_FROM &lt; current_timestamp and (acct_promo.EFFECTIVE_DATE_TO is null or acct_promo.EFFECTIVE_DATE_TO &gt; current_timestamp)
	    		group by acct_promo.ACCOUNT_NO
	    ) promo on promo.ACCOUNT_NO = temp.ACCOUNT_NO
	    --GOVT EINV
	      left join (
	        select
	        distinct topAcct.ACCOUNT_NO,
	        1 as VALUE
	        from AMTB_ACCOUNT acct
	        left join AMTB_ACCOUNT acct2 on acct.PARENT_NO = acct2.ACCOUNT_NO
	        left join AMTB_ACCOUNT acct3 on acct2.PARENT_NO = acct3.ACCOUNT_NO
	        left join AMTB_ACCOUNT topAcct on topAcct.CUST_NO = case when acct3.CUST_NO is not null then acct3.CUST_NO when acct2.CUST_NO is not null then acct2.CUST_NO else acct.CUST_NO end
	        where acct.GOVT_E_INVOICE_FLAG != 'N'
	      ) govt_einv on govt_einv.ACCOUNT_NO = temp.ACCOUNT_NO
	order by 
		case when '${11. Sort By#choice()#NC:CUSTOMER_ORDER:REQUIRED}' = 'AN' then temp.ACCOUNT_NAME else temp.MASTER_VALUE end, 
		case when '${11. Sort By#choice()#NC:CUSTOMER_ORDER:REQUIRED}' = 'AN' then temp.CUST_NO else null end</ds:sql>
  </ds:jdbc>
</ds:datasource>

