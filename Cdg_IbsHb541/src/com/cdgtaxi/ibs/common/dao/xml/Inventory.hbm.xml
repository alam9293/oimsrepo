<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.dsta.emart.model.repositories.hibernate" >
  <sql-query name="getInventoryItemTypeDto">
    <return-scalar column="itemTypeNo" type="integer"/>
    <return-scalar column="typeName" type="string"/>
    <return-scalar column="price" type="big_decimal"/>
    <return-scalar column="totalQty" type="integer"/>
    <return-scalar column="issuedQty" type="integer"/>
    <return-scalar column="stockQty" type="integer"/>
    <return-scalar column="redeemedQty" type="integer"/>
    <return-scalar column="reservedQty" type="integer"/>
    <![CDATA[
    SELECT
      itemtype.item_type_no AS itemTypeNo,
      itemtype.type_name AS typeName,
      itemtype.price AS price,
      CASE WHEN total.qty IS NULL THEN 0 ELSE total.qty END AS totalQty, 
      CASE WHEN issued.qty IS NULL THEN 0 ELSE issued.qty END AS issuedQty, 
      CASE WHEN total.qty IS NULL THEN 0 ELSE total.qty-NVL(issued.qty,0) END AS stockQty, 
      CASE WHEN redeemed.qty IS NULL THEN 0 ELSE redeemed.qty END AS redeemedQty,
      CASE WHEN reserved.qty IS NULL THEN 0 ELSE reserved.qty END AS reservedQty
    FROM
      IMTB_ITEM_TYPE itemtype
      LEFT JOIN (SELECT item_type_no, SUM(serial_no_end-serial_no_start+1) qty
                 FROM IMTB_STOCK
                 WHERE txn_type = :stockInCode
                 GROUP BY item_type_no) total
        ON total.item_type_no = itemtype.item_type_no
      LEFT JOIN (SELECT item_type_no, SUM(serial_no_end-serial_no_start+1) qty
                 FROM IMTB_STOCK
                 WHERE txn_type = :issuedCode
                 GROUP BY item_type_no) issued
        ON issued.item_type_no = itemtype.item_type_no
      LEFT JOIN (SELECT item_type_no, COUNT(item_no) qty
                 FROM IMTB_ITEM
                 WHERE status = :redeemedCode
                 GROUP BY item_type_no) redeemed
        ON redeemed.item_type_no = itemtype.item_type_no
      LEFT JOIN (SELECT item_type_no, SUM(quantity) qty
                 FROM IMTB_ISSUE_REQ r
                   INNER JOIN IMTB_ISSUE_REQ_FLOW f
                     ON r.issue_req_flow_no = f.issue_req_flow_no
                     AND (f.to_status = :pendingCode OR f.to_status = :approvedCode)
                 GROUP BY item_type_no) reserved
        ON reserved.item_type_no = itemtype.item_type_no
    WHERE
      itemtype.item_type_no = :itemTypeNo
      OR -1 = :itemTypeNo
    ORDER BY
      itemtype.item_type_no
    ]]>
  </sql-query>
  
  <sql-query name="serialNoAvailable">
    <![CDATA[
    select
      COUNT(*)
    from IMTB_STOCK
    where 
      item_type_no = :itemTypeNo
      and
      ((:serialNoStart >= SERIAL_NO_START
      and :serialNoStart <= SERIAL_NO_END)
      or  
      (:serialNoEnd >= SERIAL_NO_START
      and :serialNoEnd <= SERIAL_NO_END))
      and TXN_TYPE = :stockInCode
      and NOT EXISTS (
        SELECT
        1
        FROM imtb_stock
        WHERE 
        item_type_no = :itemTypeNo
        and txn_type = :issuedCode
        AND  ((:serialNoStart >= SERIAL_NO_START
        and :serialNoStart <= SERIAL_NO_END)
        or  (:serialNoEnd >= SERIAL_NO_START
        and :serialNoEnd <= SERIAL_NO_END))
      )
    ]]>
  </sql-query>
  
  <sql-query name="searchIssuanceRequest">
  	<return-scalar column="ISSUE_REQ_NO" type="integer"/>
    <return-scalar column="ACCOUNT_NO" type="integer"/>
    <return-scalar column="ACCOUNT_NAME" type="string"/>
    <return-scalar column="req_status" type="string"/>
    <return-scalar column="TYPE_NAME" type="string"/>
    <return-scalar column="QUANTITY" type="long"/>
    <return-scalar column="REQUEST_DT" type="timestamp"/>
    <return-scalar column="CREATE_BY" type="string"/>
    <![CDATA[
    select
    req.ISSUE_REQ_NO,
    topLevel.CUST_NO as ACCOUNT_NO,
    topLevel.ACCOUNT_NAME,
    latest_flow.STATUS as req_status,
    item_type.TYPE_NAME,
    req.QUANTITY,
    req.REQUEST_DT,
    req.CREATE_BY
    from IMTB_ISSUE_REQ req
    inner join
    (
       select
       distinct issue_req_no,
       first_value
       (
          TO_STATUS
       )
       over (partition by issue_req_no order by FLOW_DT desc) as STATUS
       from IMTB_ISSUE_REQ_FLOW
    )
    latest_flow on req.ISSUE_REQ_NO = latest_flow.ISSUE_REQ_NO
    inner join amtb_account acct on req.ACCOUNT_NO = acct.ACCOUNT_NO
    left join AMTB_ACCOUNT pacct on acct.PARENT_NO = pacct.ACCOUNT_NO
    left join AMTB_ACCOUNT gpacct on pacct.PARENT_NO = gpacct.ACCOUNT_NO
    inner join AMTB_ACCOUNT topLevel on topLevel.ACCOUNT_NO =
    (
       case when gpacct.ACCOUNT_NO is not null then gpacct.ACCOUNT_NO when pacct.ACCOUNT_NO is not null then pacct.ACCOUNT_NO else acct.ACCOUNT_NO end
    )
    inner join IMTB_ITEM_TYPE item_type on item_type.ITEM_TYPE_NO = req.ITEM_TYPE_NO
    inner join AMTB_CONTACT_PERSON contact on req.CONTACT_PERSON_NO = contact.CONTACT_PERSON_NO
    where (:requestStatus is null OR latest_flow.status = :requestStatus)
    AND (:accountNo is null OR acct.ACCOUNT_NO = :accountNo)
    AND (:accountName is null OR topLevel.account_Name like :accountName)
    AND (:custNo is null OR topLevel.cust_No = :custNo)
    AND (:requestNo is null OR req.ISSUE_REQ_NO = :requestNo)
    AND (:requestor is null OR UPPER(req.CREATE_BY) like :requestor)
    AND
    (
       :requestDateFrom is null OR req.REQUEST_DT between :requestDateFrom
       and :requestDateTo
    )
    AND (:itemTypeNo is null OR req.ITEM_TYPE_NO = :itemTypeNo)
    AND
    (
       (
          :serialNoStart is null
          AND :serialNoEnd is null
       )
       OR
       (
          :serialNoStart is not null
          AND :serialNoStart BETWEEN req.SERIAL_NO_START
          AND req.SERIAL_NO_END
       )
       OR
       (
          :serialNoEnd is not null
          AND :serialNoEnd BETWEEN req.SERIAL_NO_START
          AND req.SERIAL_NO_END
       )
    )
    ]]>
  </sql-query>
  
</hibernate-mapping>

